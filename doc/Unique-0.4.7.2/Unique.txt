-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | It provides the functionality like unix "uniq" utility
--   
--   Library provides the functions to find unique and duplicate elements
--   in the list
@package Unique
@version 0.4.7.2


-- | Library provides the functions to find unique and duplicate elements
--   in the list
module Data.List.Unique

-- | <a>complex</a> function is a complex investigation of the list. It
--   returns triple:
--   
--   <ul>
--   <li>the first - all elements with removed duplicates (like
--   <a>sortUniq</a> but the result is not sorted)</li>
--   <li>the second - the elements that are repeated at least once in the
--   list (result is the same as <a>repeated</a> but not sorted)</li>
--   <li>the third - the unique elements that do not have duplicates
--   (result is the same as <a>unique</a> but not sorted)</li>
--   </ul>
--   
--   <a>complex</a> does not sort the resulted elements of triple as well
--   as it can be used for types that does not have Ord instance.
--   
--   Anyway, it's better to use <a>sortUniq</a>, <a>repeated</a> and
--   <a>unique</a> instead of <a>complex</a> when type <tt>a</tt> has Ord
--   instance.
--   
--   <pre>
--   complex "This is the test line" == ("This teln","is hte","Tln")
--   </pre>
--   
--   Since 0.4.4
complex :: Eq a => [a] -> ([a], [a], [a])

-- | <a>isUnique</a> function is to check whether the given element is
--   unique in the list or not.
--   
--   It returns Nothing when the element does not present in the list.
--   Examples:
--   
--   <pre>
--   isUnique 'f' "foo bar" == Just True
--   isUnique 'o' "foo bar" == Just False
--   isUnique '!' "foo bar" == Nothing
--   </pre>
--   
--   Since 0.4.5
isUnique :: Eq a => a -> [a] -> Maybe Bool

-- | <a>isRepeated</a> is a reverse function to <a>isUnique</a>
--   
--   Since 0.4.5
isRepeated :: Eq a => a -> [a] -> Maybe Bool

-- | <a>sortUniq</a> sorts the list and removes the duplicates of elements.
--   Example:
--   
--   <pre>
--   sortUniq "foo bar" == " abfor"
--   </pre>
sortUniq :: Ord a => [a] -> [a]

-- | <a>repeated</a> finds only the elements that are present more than
--   once in the list. Example:
--   
--   <pre>
--   repeated  "foo bar" == "o"
--   </pre>
repeated :: Ord a => [a] -> [a]

-- | The repeatedBy function behaves just like repeated, except it uses a
--   user-supplied equality predicate.
--   
--   <pre>
--   repeatedBy (&gt;2) "This is the test line" == " eist"
--   </pre>
repeatedBy :: Ord a => (Int -> Bool) -> [a] -> [a]

-- | <a>unique</a> gets only unique elements, that do not have duplicates.
--   It sorts them. Example:
--   
--   <pre>
--   unique  "foo bar" == " abfr"
--   </pre>
unique :: Ord a => [a] -> [a]

-- | <a>allUnique</a> checks whether all elements of the list are unique
--   
--   <pre>
--   allUnique "foo bar" == False
--   allUnique ['a'..'z'] == True
--   allUnique [] == True (!)
--   </pre>
--   
--   Since 0.4.7
allUnique :: Ord a => [a] -> Bool

-- | <a>count</a> of each element in the list, it sorts by keys (elements).
--   Example:
--   
--   <pre>
--   count "foo bar" == [(' ',1),('a',1),('b',1),('f',1),('o',2),('r',1)]
--   </pre>
count :: Ord a => [a] -> [(a, Int)]

-- | <a>count_</a> of each elements in the list, it sorts by their number.
--   Example:
--   
--   <pre>
--   count_ "foo bar" == [(' ',1),('a',1),('b',1),('f',1),('r',1),('o',2)]
--   </pre>
count_ :: Ord a => [a] -> [(a, Int)]

-- | <a>occurrences</a> like <a>count</a> or <a>count_</a> but shows the
--   list of elements that occur X times
--   
--   <pre>
--   occurrences "This is the test line" == [(1,"Tln"),(2,"h"),(3,"eist"),(4," ")]
--   </pre>
--   
--   Since 0.4.4
occurrences :: Ord a => [a] -> [(Int, [a])]

-- | <a>countElem</a> gets the number of occurrences of the specified
--   element. Example:
--   
--   <pre>
--   countElem 'o' "foo bar" == 2
--   </pre>
countElem :: Eq a => a -> [a] -> Int


-- | Library provides functions to find unique and duplicate elements in
--   the list. Unlike Data.List.Unique this one uses Data.Map.Strict for
--   calculations. So it's much faster and it uses less memory.
module Data.List.UniqueStrict

-- | <a>sortUniq</a> sorts the list and removes the duplicates of elements.
--   Example:
--   
--   <pre>
--   sortUniq "foo bar" == " abfor"
--   </pre>
sortUniq :: Ord a => [a] -> [a]

-- | <a>isUnique</a> function is to check whether the given element is
--   unique in the list or not.
--   
--   It returns Nothing when the element does not present in the list.
--   Examples:
--   
--   <pre>
--   isUnique 'f' "foo bar" == Just True
--   isUnique 'o' "foo bar" == Just False
--   isUnique '!' "foo bar" == Nothing
--   </pre>
--   
--   Since 0.4.7.2
isUnique :: Ord a => a -> [a] -> Maybe Bool

-- | <a>isRepeated</a> is a reverse function to <a>isUnique</a>
--   
--   Since 0.4.5
isRepeated :: Ord a => a -> [a] -> Maybe Bool

-- | <a>repeated</a> finds only the elements that are present more than
--   once in the list. Example:
--   
--   <pre>
--   repeated  "foo bar" == "o"
--   </pre>
repeated :: Ord a => [a] -> [a]

-- | The <a>repeatedBy</a> function behaves just like repeated, except it
--   uses a user-supplied equality predicate.
--   
--   <pre>
--   repeatedBy (&gt;2) "This is the test line" == " eist"
--   </pre>
repeatedBy :: Ord a => (Int -> Bool) -> [a] -> [a]

-- | <a>unique</a> gets only unique elements, that do not have duplicates.
--   It sorts them. Example:
--   
--   <pre>
--   unique  "foo bar" == " abfr"
--   </pre>
unique :: Ord a => [a] -> [a]

-- | <a>allUnique</a> checks whether all elements of the list are unique
--   
--   <pre>
--   allUnique "foo bar" == False
--   allUnique ['a'..'z'] == True
--   allUnique [] == True (!)
--   </pre>
--   
--   Since 0.4.7.2
allUnique :: Ord a => [a] -> Bool

-- | <a>count</a> of each element in the list, it sorts by keys (elements).
--   Example:
--   
--   <pre>
--   count "foo bar" == [(' ',1),('a',1),('b',1),('f',1),('o',2),('r',1)]
--   </pre>
count :: Ord a => [a] -> [(a, Int)]

-- | <a>count_</a> of each elements in the list, it sorts by their number.
--   Example:
--   
--   <pre>
--   count_ "foo bar" == [(' ',1),('a',1),('b',1),('f',1),('r',1),('o',2)]
--   </pre>
count_ :: Ord a => [a] -> [(a, Int)]


-- | Library provides functions to find unique and duplicate elements in
--   the list. Unlike Unique or UniqueStrict modules this one uses
--   Data.HashMap.Strict for calculation.
--   
--   The elements in the list can be unsorted (do not have an instance of
--   Ord class, but Hashable is needed). This implementation is good for
--   ByteStrings.
module Data.List.UniqueUnsorted

-- | <a>isUnique</a> function is to check whether the given element is
--   unique in the list or not.
--   
--   It returns Nothing when the element does not present in the list.
--   Examples:
--   
--   <pre>
--   isUnique 'f' "foo bar" == Just True
--   isUnique 'o' "foo bar" == Just False
--   isUnique '!' "foo bar" == Nothing
--   </pre>
--   
--   Since 0.4.7.2
isUnique :: (Hashable a, Eq a) => a -> [a] -> Maybe Bool

-- | <a>isRepeated</a> is a reverse function to <a>isUnique</a>
--   
--   Since 0.4.7.2
isRepeated :: (Hashable a, Eq a) => a -> [a] -> Maybe Bool

-- | <a>removeDuplicates</a> removes the duplicates of elements. Example:
--   
--   <pre>
--   removeDuplicates "foo bar" == " abrfo"
--   </pre>
removeDuplicates :: (Hashable a, Eq a) => [a] -> [a]

-- | <a>repeated</a> finds only the elements that are present more than
--   once in the list. Example:
--   
--   <pre>
--   repeated  "foo bar" == "o"
--   </pre>
repeated :: (Hashable a, Eq a) => [a] -> [a]

-- | The <a>repeatedBy</a> function behaves just like <a>repeated</a>,
--   except it uses a user-supplied equality predicate.
--   
--   <pre>
--   repeatedBy (&gt;2) "This is the test line" == " stei"
--   </pre>
repeatedBy :: (Hashable a, Eq a) => (Int -> Bool) -> [a] -> [a]

-- | <a>unique</a> gets only unique elements, that do not have duplicates.
--   
--   <pre>
--   unique  "foo bar" == " abrf"
--   </pre>
unique :: (Hashable a, Eq a) => [a] -> [a]

-- | <a>allUnique</a> checks whether all elements of the list are unique
--   
--   <pre>
--   allUnique "foo bar" == False
--   allUnique ['a'..'z'] == True
--   allUnique [] == True (!)
--   </pre>
--   
--   Since 0.4.7.2
allUnique :: (Hashable a, Eq a) => [a] -> Bool

-- | <a>count</a> of each element in the list. Example:
--   
--   <pre>
--   count "This is the test line" == [(' ',4),('s',3),('T',1),('t',3),('e',3),('h',2),('i',3),('l',1),('n',1)]
--   </pre>
count :: (Hashable a, Eq a) => [a] -> [(a, Int)]

-- | <a>count_</a> of each elements in the list, it sorts by their number.
--   Example:
--   
--   <pre>
--   count_ "This is the test line" == [('n',1),('l',1),('T',1),('h',2),('i',3),('e',3),('t',3),('s',3),(' ',4)]
--   </pre>
count_ :: (Hashable a, Eq a) => [a] -> [(a, Int)]
