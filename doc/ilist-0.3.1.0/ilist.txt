-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optimised list functions for doing index-related things
--   
--   Optimised list functions for doing index-related things. They're
--   faster than common idioms in all cases, they avoid <a>space leaks</a>,
--   and sometimes they fuse better as well.
@package ilist
@version 0.3.1.0


-- | Note: a lot of these functions are available for other types (in their
--   respective packages):
--   
--   <ul>
--   <li><tt><a>Data.Vector</a></tt> provides <a>indexed</a> and lots of
--   other functions beginning with “i”.</li>
--   <li><tt><a>Data.Map</a></tt> and <tt><a>Data.Sequence</a></tt> provide
--   similar functions, but use a different naming convention (e.g.
--   <tt><a>mapWithKey</a></tt> for maps and <tt><a>foldrWithIndex</a></tt>
--   for sequences).</li>
--   <li><a>lens</a> provides several typeclasses for indexed functions
--   that work on maps, lists, vectors, bytestrings, and so on (in
--   <tt><a>Control.Lens.Indexed</a></tt>), but unfortunately they are
--   pretty slow for lists.</li>
--   </ul>
module Data.List.Index

-- | <a>indexed</a> pairs each element with its index.
--   
--   <pre>
--   &gt;&gt;&gt; indexed "hello"
--   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
--   </pre>
--   
--   <i>Subject to fusion.</i>
indexed :: [a] -> [(Int, a)]

-- | <a>deleteAt</a> deletes the element at an index.
--   
--   If the index is negative or exceeds list length, the original list
--   will be returned.
deleteAt :: Int -> [a] -> [a]

-- | <a>setAt</a> sets the element at the index.
--   
--   If the index is negative or exceeds list length, the original list
--   will be returned.
setAt :: Int -> a -> [a] -> [a]

-- | <a>modifyAt</a> applies a function to the element at the index.
--   
--   If the index is negative or exceeds list length, the original list
--   will be returned.
modifyAt :: Int -> (a -> a) -> [a] -> [a]

-- | <a>updateAt</a> applies a function to the element at the index, and
--   then either replaces the element or deletes it (if the function has
--   returned <a>Nothing</a>).
--   
--   If the index is negative or exceeds list length, the original list
--   will be returned.
updateAt :: Int -> (a -> Maybe a) -> [a] -> [a]

-- | <a>insertAt</a> inserts an element at the given position:
--   
--   <pre>
--   (insertAt i x xs) !! i == x
--   </pre>
--   
--   If the index is negative or exceeds list length, the original list
--   will be returned. (If the index is equal to the list length, the
--   insertion can be carried out.)
insertAt :: Int -> a -> [a] -> [a]

-- | <i>Subject to fusion.</i>
imap :: (Int -> a -> b) -> [a] -> [b]
imapM :: Monad m => (Int -> a -> m b) -> [a] -> m [b]

-- | <i>Subject to fusion.</i>
imapM_ :: Monad m => (Int -> a -> m b) -> [a] -> m ()
ifor :: Applicative m => [a] -> (Int -> a -> m b) -> m [b]

-- | <i>Subject to fusion.</i>
ifor_ :: Applicative m => [a] -> (Int -> a -> m b) -> m ()
ifoldr :: (Int -> a -> b -> b) -> b -> [a] -> b

-- | The index isn't the first argument of the function because that's the
--   convention adopted by containers and vector (but not lens).
--   
--   <i>Subject to fusion.</i>
ifoldl :: forall a b. (b -> Int -> a -> b) -> b -> [a] -> b

-- | <i>Subject to fusion.</i>
ifoldl' :: forall a b. (b -> Int -> a -> b) -> b -> [a] -> b

-- | <i>Subject to fusion.</i>
iall :: (Int -> a -> Bool) -> [a] -> Bool

-- | <i>Subject to fusion.</i>
iany :: (Int -> a -> Bool) -> [a] -> Bool
iconcatMap :: (Int -> a -> [b]) -> [a] -> [b]
ifilter :: (Int -> a -> Bool) -> [a] -> [a]
ipartition :: (Int -> a -> Bool) -> [a] -> ([a], [a])
itakeWhile :: (Int -> a -> Bool) -> [a] -> [a]
idropWhile :: (Int -> a -> Bool) -> [a] -> [a]

-- | <i>Subject to fusion in the first argument.</i>
izipWith :: (Int -> a -> b -> c) -> [a] -> [b] -> [c]
izipWithM :: Applicative f => (Int -> a -> b -> f c) -> [a] -> [b] -> f [c]
izipWithM_ :: Applicative f => (Int -> a -> b -> f c) -> [a] -> [b] -> f ()
ifind :: (Int -> a -> Bool) -> [a] -> Maybe (Int, a)
ifindIndex :: (Int -> a -> Bool) -> [a] -> Maybe Int
ifindIndices :: (Int -> a -> Bool) -> [a] -> [Int]
izipWith3 :: (Int -> a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
izipWith4 :: (Int -> a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
izipWith5 :: (Int -> a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
izipWith6 :: (Int -> a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
izipWith7 :: (Int -> a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
iforM :: Monad m => [a] -> (Int -> a -> m b) -> m [b]

-- | <i>Subject to fusion.</i>
iforM_ :: Monad m => [a] -> (Int -> a -> m b) -> m ()
itraverse :: Applicative m => (Int -> a -> m b) -> [a] -> m [b]

-- | <i>Subject to fusion.</i>
itraverse_ :: Applicative m => (Int -> a -> m b) -> [a] -> m ()

-- | Perform a given action <tt>n</tt> times. Behaves like <tt>for_
--   [0..n-1]</tt>, but avoids <a>space leaks</a>.
--   
--   If you want more complicated loops (e.g. counting downwards), consider
--   the <a>loop</a> package.
ireplicateM :: Applicative m => Int -> (Int -> m a) -> m [a]

-- | NB. This function intentionally uses <a>Monad</a> even though
--   <a>Applicative</a> is enough. That's because the <tt>transformers</tt>
--   package didn't have an optimized definition of (<a>*&gt;</a>) for
--   <tt>StateT</tt> prior to 0.5.3.0, so for a common case of
--   <tt>StateT</tt> this function would be 40 times slower with the
--   <a>Applicative</a> constraint.
ireplicateM_ :: Monad m => Int -> (Int -> m a) -> m ()
ifoldrM :: Monad m => (Int -> a -> b -> m b) -> b -> [a] -> m b

-- | <i>Subject to fusion.</i>
ifoldlM :: Monad m => (b -> Int -> a -> m b) -> b -> [a] -> m b
ifoldMap :: Monoid m => (Int -> a -> m) -> [a] -> m
imapAccumR :: (acc -> Int -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
imapAccumL :: (acc -> Int -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
