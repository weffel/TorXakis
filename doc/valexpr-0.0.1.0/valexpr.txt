-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Value Expressions
--   
--   Value Expressions
@package valexpr
@version 0.0.1.0


-- | This module provides a type-wrapper around id's.
module Id
newtype Id
Id :: Int -> Id
[_id] :: Id -> Int

-- | Types that contain values of type <tt>Id</tt> that can be reset (set
--   to zero).
class Resettable e

-- | Reset all the <tt>Id</tt>'s inside an expression.
reset :: Resettable e => e -> e

-- | Reset all the <tt>Id</tt>'s inside an expression.
reset :: (Resettable e, Generic e, GResettable (Rep e)) => e -> e

-- | We don't want to reset <tt>Integer</tt>s, since they are not
--   <tt>Id</tt>s.
class GResettable f
gReset :: GResettable f => f e -> f e

-- | Resetting a constructor without arguments will give the same result,
--   since no <tt>Id</tt> can be found there.

-- | Resetting the product is equal to resetting each term in the product.

-- | Resetting the sum amounts to resetting the each term of it as well.

-- | We do need to do anything for resetting the meta-data.

-- | And the only interesting case: resetting the arguments of the type
--   constructors. In this case we have to use our <tt>Reset</tt> (<b>not
--   <tt>GReset</tt></b>).

-- | Values that contain at least a value of type <tt>Id</tt>.
class Identifiable e
getId :: Identifiable e => e -> Maybe Id
getId :: (Identifiable e, Generic e, GIdentifiable (Rep e)) => e -> Maybe Id
class GIdentifiable f
gGetId :: GIdentifiable f => f e -> Maybe Id

-- | Getting the identifier of a product amounts to getting the first
--   <tt>Id</tt> identifiable of the first identifiable value. An
--   identifiable instance should contain at least one such a value, but we
--   do now check for this.

-- | Getting the <tt>Id</tt> of a constructor is the same as getting the
--   <tt>Id</tt> of its argument.
instance Data.Data.Data Id.Id
instance Control.DeepSeq.NFData Id.Id
instance GHC.Read.Read Id.Id
instance GHC.Num.Num Id.Id
instance GHC.Enum.Enum Id.Id
instance GHC.Classes.Ord Id.Id
instance GHC.Classes.Eq Id.Id
instance Id.Identifiable Id.Id
instance Id.Identifiable Data.Text.Internal.Text
instance Id.Identifiable a => Id.Identifiable [a]
instance Id.Identifiable a => Id.GIdentifiable (GHC.Generics.K1 i a)
instance Id.GIdentifiable GHC.Generics.U1
instance (Id.GIdentifiable a, Id.GIdentifiable b) => Id.GIdentifiable (a GHC.Generics.:*: b)
instance (Id.GIdentifiable a, Id.GIdentifiable b) => Id.GIdentifiable (a GHC.Generics.:+: b)
instance Id.GIdentifiable a => Id.GIdentifiable (GHC.Generics.M1 i c a)
instance Id.Resettable Id.Id
instance Id.Resettable ()
instance Id.Resettable GHC.Types.Bool
instance Id.Resettable GHC.Types.Char
instance Id.Resettable Data.Text.Internal.Text
instance Id.Resettable GHC.Integer.Type.Integer
instance Id.Resettable GHC.Types.Int
instance Id.Resettable a => Id.Resettable [a]
instance (Id.Resettable a, Id.Resettable b) => Id.Resettable (a, b)
instance (GHC.Classes.Ord a, Id.Resettable a) => Id.Resettable (Data.Set.Internal.Set a)
instance (GHC.Classes.Ord k, Id.Resettable k, Id.Resettable v) => Id.Resettable (Data.Map.Internal.Map k v)
instance Id.Resettable a => Id.GResettable (GHC.Generics.K1 i a)
instance Id.GResettable GHC.Generics.U1
instance (Id.GResettable a, Id.GResettable b) => Id.GResettable (a GHC.Generics.:*: b)
instance (Id.GResettable a, Id.GResettable b) => Id.GResettable (a GHC.Generics.:+: b)
instance Id.GResettable a => Id.GResettable (GHC.Generics.M1 i c a)
instance GHC.Show.Show Id.Id


-- | <pre>
--   a0 &lt;&gt; a1 &lt;&gt; ... &lt;&gt; an-1
--   </pre>
--   
--   `ai in A`, <a>&lt;&gt;</a> is a commutative (binary) operation, `(A,
--   &lt;&gt;)` is a Monoid, there is a multiplication operator
--   <a>&lt;.&gt;</a> that is distributive w.r.t <a>&lt;&gt;</a>, and there
--   is additive inverse for the elements of <tt>A</tt>:
--   
--   <pre>
--   a &lt;&gt; b         = b &lt;&gt; a                 -- for all a, b in A (commutativity)
--   a &lt;.&gt; (b &lt;&gt; c) = (a &lt;.&gt; b) &lt;&gt; (a &lt;.&gt; c) -- for all a, b, c in A (left distributivity).
--   (b &lt;&gt; c) &lt;.&gt; a = (b &lt;.&gt; a) &lt;&gt; (c &lt;.&gt; a) -- for all a, b, c in A (right distributivity).
--   a &lt;&gt; -a        = 0                      -- for all a, for some (-a), where `0 = mempty`.
--   </pre>
--   
--   Furthermore, to be able to assign semantics to this symbolic
--   representation it is required that the terms are integer-multipliable,
--   meaning that
--   
--   <pre>
--   `a &lt;.&gt; n`
--   </pre>
--   
--   is equivalent to adding an element <tt>a</tt> <tt>n</tt> times if
--   <tt>n</tt> is non-negative, or removing it <tt>n</tt> times otherwise.
--   See <a>IntMultipliable</a> class, and <tt>multiplyLaw</tt> in
--   <tt>FreeMonoidXSpec</tt>.
--   
--   Note that we're using <a>&lt;.&gt;</a> as having both types `A -&gt;
--   A` and `Integral n =&gt; n -&gt; a`, which is fine at the moment since
--   the <a>FreeMonoidX</a>'s we are dealing with are numeric types.
--   
--   `FreeMonoidX a` is an instance of the <a>IsList</a> class, which means
--   that in combination with the <tt>OverloadedLists</tt> extension is
--   possible to write free-monoids as lists. For instance the free-monoid:
--   
--   <pre>
--   a0 &lt;&gt; a1 &lt;&gt; ... &lt;&gt; an-1
--   </pre>
--   
--   Can be written as
--   
--   <ul>
--   <li><i>a0, a1, ..., an-1</i></li>
--   </ul>
module FreeMonoidX

-- | Symbolic representation of a polynomial, where each term is a member
--   of type <tt>a</tt>.
--   
--   The integer value of the map represents the number of occurrences of a
--   term in the polynomial. Given this representation it is crucial that
--   the operation is commutative, since the information of about the order
--   of the term is lost in this representation.
newtype FreeMonoidX a
FMX :: Map a Integer -> FreeMonoidX a
[asMap] :: FreeMonoidX a -> Map a Integer

-- | Number of distinct terms in the free-monoid.
nrofDistinctTerms :: FreeMonoidX a -> Int

-- | <i>O(n)</i>. The distinct terms of a free-monoid., each term occurs
--   only once in the list.
distinctTerms :: FreeMonoidX a -> [a]
distinctTermsT :: TermWrapper t => FreeMonoidX (t a) -> [a]

-- | Map the terms of the free-monoid.
mapTerms :: Ord b => (a -> b) -> FreeMonoidX a -> FreeMonoidX b

-- | <i>O(n)</i>. Partition the free-monoid into two free-monoids, one with
--   all elements that satisfy the predicate and one with all elements that
--   don't satisfy the predicate.
partition :: (a -> Bool) -> FreeMonoidX a -> (FreeMonoidX a, FreeMonoidX a)
partitionT :: TermWrapper t => (a -> Bool) -> FreeMonoidX (t a) -> (FreeMonoidX (t a), FreeMonoidX (t a))

-- | <i>O(n)</i>. Fold over the terms of the free-monoid with their
--   multipliers.
foldOccur :: (a -> Integer -> b -> b) -> b -> FreeMonoidX a -> b

-- | Fold the free-monoid.
foldFMX :: (IntMultipliable a, Monoid a, Semigroup a) => FreeMonoidX a -> a

-- | Append a term to the free-monoid.
--   
--   <pre>
--   append 2 [1, 2, 3]
--   </pre>
--   
--   should be equivalent to the free-monoid.
--   
--   <pre>
--   [1, 2, 3, 2]
--   </pre>
append :: Ord a => a -> FreeMonoidX a -> FreeMonoidX a

-- | Remove a term from the free-monoid.
--   
--   <pre>
--   remove 2 (1 &lt;&gt; 2 &lt;&gt; 3)
--   </pre>
--   
--   should be equivalent to the free-monoid
--   
--   <pre>
--   (1 &lt;&gt; 3)
--   </pre>
remove :: Ord a => a -> FreeMonoidX a -> FreeMonoidX a

-- | Add the term <tt>x</tt> <tt>n</tt> times. If <tt>n</tt> is negative
--   the term will be removed <tt>n</tt> times.
--   
--   <pre>
--   appendMany 2 10 (10 &lt;&gt; 12 &lt;&gt; 12)
--   </pre>
--   
--   should be equivalent to
--   
--   (10 &lt;&gt; 10 &lt;&gt; 10 &lt;&gt; 12 &lt;&gt; 12)
--   
--   <pre>
--   appendMany (-2) 10 (10 &lt;&gt; 12 &lt;&gt; 12)
--   </pre>
--   
--   should be equivalent to
--   
--   <pre>
--   (-10 &lt;&gt; 12 &lt;&gt; 12)
--   </pre>
appendMany :: Ord a => Integer -> a -> FreeMonoidX a -> FreeMonoidX a

-- | Flatten a free-monoid.
--   
--   For instance, the monoid
--   
--   <pre>
--   (a &lt;&gt; b) &lt;&gt; (a &lt;&gt; b) &lt;&gt; a
--   </pre>
--   
--   will be rewritten as:
--   
--   <pre>
--   a &lt;&gt; a &lt;&gt; a &lt;&gt; b &lt;&gt; b
--   </pre>
--   
--   Assuming `a &lt; b`.
flatten :: (Ord a) => FreeMonoidX (FreeMonoidX a) -> FreeMonoidX a

-- | `n <a>.</a> x` multiplies <tt>x</tt> <tt>n</tt> times.
(<.>) :: (IntMultipliable a, Integral n) => n -> a -> a

-- | Types that can be multiplied by an integral. This restriction is
--   required to be able to assign a correct semantic to the symbolic
--   representation of the free-monoid. If the elements of the free-monoid
--   are not <a>IntMultipliable</a>, then <a>foldFMX</a> is ill-defined.
--   
--   See the test code <tt>FreeMonoidXspec</tt> for examples of instances
--   of this class.
class IntMultipliable a

-- | `n <a>.</a> x` multiplies <tt>x</tt> <tt>n</tt> times.
(<.>) :: (IntMultipliable a, Integral n) => n -> a -> a

-- | A term of the monoid which wraps a value. This could be for instance a
--   sum-term or a product term.
class TermWrapper f
wrap :: TermWrapper f => a -> f a
unwrap :: TermWrapper f => f a -> a

-- | <i>O(n)</i>. Convert the free-monoid to a list of (term, occurrence)
--   tuples.
--   
--   For instance given the term:
--   
--   <pre>
--   a &lt;&gt; b &lt;&gt; a &lt;&gt; b &lt;&gt; a
--   </pre>
--   
--   <a>toOccurList</a> applied to it will result in the following list:
--   
--   <pre>
--   [(a, 3), (b, 2)]
--   </pre>
toOccurList :: FreeMonoidX a -> [(a, Integer)]

-- | <i>O(n)</i>. Convert the free-monoid to a distinct ascending list of
--   term/multiplier pairs.
toDistinctAscOccurList :: FreeMonoidX a -> [(a, Integer)]

-- | <i>O(n*log n)</i>. Create a free-monoid from a list of term/multiplier
--   pairs.
fromOccurList :: Ord a => [(a, Integer)] -> FreeMonoidX a

-- | <i>O(n)</i>. Build a free-monoid from an ascending list of
--   term/multiplier pairs where each term appears only once. /The
--   precondition (input list is strictly ascending) is not checked./
fromDistinctAscOccurList :: [(a, Integer)] -> FreeMonoidX a

-- | <i>O(t*log t)</i>. Create a product from a list of terms using the
--   given term wrapper.
fromListT :: (Ord (t a), TermWrapper t) => [a] -> FreeMonoidX (t a)
toOccurListT :: TermWrapper t => FreeMonoidX (t a) -> [(a, Integer)]
toDistinctAscOccurListT :: TermWrapper t => FreeMonoidX (t a) -> [(a, Integer)]
fromOccurListT :: (Ord (t a), TermWrapper t) => [(a, Integer)] -> FreeMonoidX (t a)
fromDistinctAscPowerListT :: TermWrapper t => [(a, Integer)] -> FreeMonoidX (t a)
instance (GHC.Classes.Ord a, Data.Data.Data a) => Data.Data.Data (FreeMonoidX.FreeMonoidX a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (FreeMonoidX.FreeMonoidX a)
instance GHC.Generics.Generic (FreeMonoidX.FreeMonoidX a)
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (FreeMonoidX.FreeMonoidX a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (FreeMonoidX.FreeMonoidX a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (FreeMonoidX.FreeMonoidX a)
instance GHC.Classes.Ord a => FreeMonoidX.IntMultipliable (FreeMonoidX.FreeMonoidX a)
instance GHC.Show.Show a => GHC.Show.Show (FreeMonoidX.FreeMonoidX a)
instance (GHC.Classes.Ord a, Id.Resettable a) => Id.Resettable (FreeMonoidX.FreeMonoidX a)
instance GHC.Classes.Ord a => Data.Semigroup.Semigroup (FreeMonoidX.FreeMonoidX a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (FreeMonoidX.FreeMonoidX a)
instance GHC.Classes.Ord a => GHC.Exts.IsList (FreeMonoidX.FreeMonoidX a)


-- | Name
module Name

-- | Name of definition.
type Name = Text


-- | Implementation for a symbolic product.
--   
--   Note: Integer division is not associative, so negative occurrences
--   should be not be used for Integers.
--   
--   inspiration taken from
--   <a>https://hackage.haskell.org/package/multiset-0.3.3/docs/src/Data-MultiSet.html</a>
--   
--   We take 0^0 == 1
--   
--   In the complexity of functions <i>n</i> refers to the number of
--   distinct terms, <i>t</i> is the total number of terms.
module Product

-- | <a>FreeProduct</a> represents a symbolic product of terms of the type
--   parameter <tt>a</tt>. The same term can occur multiple times.
type FreeProduct a = FreeMonoidX (ProductTerm a)

-- | Terms of a free-monoids of the form:
--   
--   <pre>
--   a0 &lt;&gt; a1 &lt;&gt; ... &lt;&gt; an-1
--   </pre>
--   
--   where <a>&lt;&gt;</a> will be interpreted as the arithmetic
--   multiplication of terms:
--   
--   <pre>
--   a0 * a1 * ... * an-1
--   </pre>
newtype ProductTerm a
ProductTerm :: a -> ProductTerm a
[factor] :: ProductTerm a -> a

-- | <i>O(n)</i>. Partition the product into the dividend and divisor.
fraction :: Ord a => FreeProduct a -> (FreeProduct a, FreeProduct a)

-- | <i>O(log n)</i>. Multiply a product with a term.
multiply :: Ord a => a -> FreeProduct a -> FreeProduct a

-- | <i>O(log n)</i>. Divide a product by a term.
divide :: Ord a => a -> FreeProduct a -> FreeProduct a

-- | <i>O(n+m)</i>. The product of two products.
product :: Ord a => FreeProduct a -> FreeProduct a -> FreeProduct a

-- | The product of a list of products.
products :: Ord a => [FreeProduct a] -> FreeProduct a

-- | <i>O(n)</i>. Take the product <i>ms</i> to the power with the constant
--   <i>x</i>.
power :: Ord a => Integer -> FreeProduct a -> FreeProduct a
instance Data.Data.Data a => Data.Data.Data (Product.ProductTerm a)
instance GHC.Base.Functor Product.ProductTerm
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Product.ProductTerm a)
instance GHC.Generics.Generic (Product.ProductTerm a)
instance GHC.Show.Show a => GHC.Show.Show (Product.ProductTerm a)
instance GHC.Read.Read a => GHC.Read.Read (Product.ProductTerm a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Product.ProductTerm a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Product.ProductTerm a)
instance Id.Resettable a => Id.Resettable (Product.ProductTerm a)
instance GHC.Base.Applicative Product.ProductTerm
instance GHC.Num.Num a => Data.Semigroup.Semigroup (Product.ProductTerm a)
instance GHC.Num.Num a => GHC.Base.Monoid (Product.ProductTerm a)
instance FreeMonoidX.TermWrapper Product.ProductTerm
instance GHC.Real.Integral a => FreeMonoidX.IntMultipliable (Product.ProductTerm a)


-- | Transcribe regular expression between different representations.
--   
--   For more info on * XSD representation see
--   <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a> * Posix reprentation
--   see <a>https://wiki.haskell.org/Regular_expressions#regex-posix</a>
module RegexXSD2Posix

-- | Transcribe regular expression in XSD to Posix representation.
xsd2posix :: Text -> Text
instance GHC.Base.Functor RegexXSD2Posix.HappyIdentity
instance GHC.Base.Applicative RegexXSD2Posix.HappyIdentity
instance GHC.Base.Monad RegexXSD2Posix.HappyIdentity


-- | Sort Definition
module SortDef

-- | SortDef has no information
data SortDef
SortDef :: SortDef
instance Control.DeepSeq.NFData SortDef.SortDef
instance GHC.Generics.Generic SortDef.SortDef
instance GHC.Show.Show SortDef.SortDef
instance GHC.Read.Read SortDef.SortDef
instance GHC.Classes.Ord SortDef.SortDef
instance GHC.Classes.Eq SortDef.SortDef
instance Id.Resettable SortDef.SortDef


-- | Data structure for identifiers for sorts
module SortId

-- | Identifier for Sort
data SortId
SortId :: Name -> Id -> SortId
[name] :: SortId -> Name
[unid] :: SortId -> Id

-- | SortId is Resettable

-- | SortId is Identifiable

-- | Identifier for Sort Bool
sortIdBool :: SortId

-- | Identifier for Sort Int
sortIdInt :: SortId

-- | Identifier for Sort String
sortIdString :: SortId

-- | Identifier for Sort Regex
sortIdRegex :: SortId
instance Data.Data.Data SortId.SortId
instance Control.DeepSeq.NFData SortId.SortId
instance GHC.Generics.Generic SortId.SortId
instance GHC.Show.Show SortId.SortId
instance GHC.Read.Read SortId.SortId
instance GHC.Classes.Ord SortId.SortId
instance GHC.Classes.Eq SortId.SortId
instance Id.Resettable SortId.SortId
instance Id.Identifiable SortId.SortId

module FuncId
data FuncId
FuncId :: Name -> Id -> [SortId] -> SortId -> FuncId
[name] :: FuncId -> Name
[unid] :: FuncId -> Id
[funcargs] :: FuncId -> [SortId]
[funcsort] :: FuncId -> SortId
instance Data.Data.Data FuncId.FuncId
instance Control.DeepSeq.NFData FuncId.FuncId
instance GHC.Generics.Generic FuncId.FuncId
instance GHC.Show.Show FuncId.FuncId
instance GHC.Read.Read FuncId.FuncId
instance GHC.Classes.Ord FuncId.FuncId
instance GHC.Classes.Eq FuncId.FuncId
instance Id.Resettable FuncId.FuncId
instance Id.Identifiable FuncId.FuncId


-- | Data structure for constructors
module CstrDef

-- | A constructor has a <tt>isCstr</tt> functions, and a list of accessors
--   functions.
data CstrDef
CstrDef :: FuncId -> [FuncId] -> CstrDef
instance Control.DeepSeq.NFData CstrDef.CstrDef
instance GHC.Generics.Generic CstrDef.CstrDef
instance GHC.Show.Show CstrDef.CstrDef
instance GHC.Read.Read CstrDef.CstrDef
instance GHC.Classes.Ord CstrDef.CstrDef
instance GHC.Classes.Eq CstrDef.CstrDef
instance Id.Resettable CstrDef.CstrDef


-- | Data structure for identifiers for constructors
module CstrId

-- | Identifier for Constructor
data CstrId
CstrId :: Name -> Id -> [SortId] -> SortId -> CstrId
[name] :: CstrId -> Name
[unid] :: CstrId -> Id
[cstrargs] :: CstrId -> [SortId]
[cstrsort] :: CstrId -> SortId

-- | CstrId is Resettable

-- | CstrId is Identifiable
instance Data.Data.Data CstrId.CstrId
instance Control.DeepSeq.NFData CstrId.CstrId
instance GHC.Generics.Generic CstrId.CstrId
instance GHC.Show.Show CstrId.CstrId
instance GHC.Read.Read CstrId.CstrId
instance GHC.Classes.Ord CstrId.CstrId
instance GHC.Classes.Eq CstrId.CstrId
instance Id.Resettable CstrId.CstrId
instance Id.Identifiable CstrId.CstrId


-- | SortOf for Value Expressions
module SortOf

-- | Sort of a value expression
class SortOf s
sortOf :: SortOf s => s -> SortId


-- | Data structure for constant definitions.
module ConstDefs

-- | Union of Boolean, Integer, String, and AlgebraicDataType constant
--   values.
data Const
Cbool :: Bool -> Const
[cBool] :: Const -> Bool
Cint :: Integer -> Const
[cInt] :: Const -> Integer
Cstring :: Text -> Const
[cString] :: Const -> Text

-- | XSD input PvdL: performance gain: translate only once, storing SMT
--   string as well
Cregex :: Text -> Const
[cRegex] :: Const -> Text
Cstr :: CstrId -> [Const] -> Const
[cstrId] :: Const -> CstrId
[args] :: Const -> [Const]
Cany :: SortId -> Const
[sort] :: Const -> SortId

-- | Const is Resettable

-- | Const has a Sort.
instance Data.Data.Data ConstDefs.Const
instance Control.DeepSeq.NFData ConstDefs.Const
instance GHC.Generics.Generic ConstDefs.Const
instance GHC.Show.Show ConstDefs.Const
instance GHC.Read.Read ConstDefs.Const
instance GHC.Classes.Ord ConstDefs.Const
instance GHC.Classes.Eq ConstDefs.Const
instance Id.Resettable ConstDefs.Const
instance SortOf.SortOf ConstDefs.Const


-- | Implementation for a symbolic sum.
--   
--   inspiration taken from
--   <a>https://hackage.haskell.org/package/multiset-0.3.3/docs/src/Data-MultiSet.html</a>
--   
--   In the complexity of functions <i>n</i> refers to the number of
--   distinct terms, <i>t</i> is the total number of terms.
module Sum

-- | <a>FreeSum</a> represents a symbolic sum of terms of the type
--   parameter <tt>a</tt>. The same term can occur multiple times.
type FreeSum a = FreeMonoidX (SumTerm a)

-- | Terms of a free-monoids of the form:
--   
--   <pre>
--   a0 &lt;&gt; a1 &lt;&gt; ... &lt;&gt; an-1
--   </pre>
--   
--   where <a>&lt;&gt;</a> will be interpreted as the arithmetic sum of
--   terms:
--   
--   <pre>
--   a0 + a1 + ... + an-1
--   </pre>
newtype SumTerm a
SumTerm :: a -> SumTerm a
[summand] :: SumTerm a -> a

-- | <i>O(log n)</i>. Add a term to a sum.
add :: Ord a => a -> FreeSum a -> FreeSum a

-- | <i>O(log n)</i>. Subtract a term from a sum.
subtract :: Ord a => a -> FreeSum a -> FreeSum a

-- | <i>O(n+m)</i>. The sum of two sums.
sum :: Ord a => FreeSum a -> FreeSum a -> FreeSum a

-- | The sum of a list of sums.
sums :: (Ord a) => [FreeSum a] -> FreeSum a

-- | <i>O(n)</i>. Multiply the constant with the sum.
multiply :: Ord a => Integer -> FreeSum a -> FreeSum a
instance Data.Data.Data a => Data.Data.Data (Sum.SumTerm a)
instance GHC.Base.Functor Sum.SumTerm
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Sum.SumTerm a)
instance GHC.Generics.Generic (Sum.SumTerm a)
instance GHC.Show.Show a => GHC.Show.Show (Sum.SumTerm a)
instance GHC.Read.Read a => GHC.Read.Read (Sum.SumTerm a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Sum.SumTerm a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Sum.SumTerm a)
instance Id.Resettable a => Id.Resettable (Sum.SumTerm a)
instance GHC.Num.Num a => Data.Semigroup.Semigroup (Sum.SumTerm a)
instance GHC.Num.Num a => GHC.Base.Monoid (Sum.SumTerm a)
instance FreeMonoidX.TermWrapper Sum.SumTerm
instance GHC.Real.Integral a => FreeMonoidX.IntMultipliable (Sum.SumTerm a)

module Variable
class (Eq v, Ord v, Read v, Show v) => Variable v
vname :: Variable v => v -> Name
vunid :: Variable v => v -> Int
vsort :: Variable v => v -> SortId
cstrVariable :: Variable v => String -> Int -> SortId -> v

module VarId
data VarId
VarId :: Name -> Id -> SortId -> VarId
[name] :: VarId -> Name
[unid] :: VarId -> Id
[varsort] :: VarId -> SortId
instance Data.Data.Data VarId.VarId
instance Control.DeepSeq.NFData VarId.VarId
instance GHC.Generics.Generic VarId.VarId
instance GHC.Show.Show VarId.VarId
instance GHC.Read.Read VarId.VarId
instance GHC.Classes.Ord VarId.VarId
instance GHC.Classes.Eq VarId.VarId
instance Variable.Variable VarId.VarId
instance Id.Resettable VarId.VarId
instance Id.Identifiable VarId.VarId
instance SortOf.SortOf VarId.VarId


-- | Function Definition
module FuncDef

-- | Data structure to store the information of a Function Definition: * A
--   list of variables * A body (possibly using the variables)
data FuncDef v
FuncDef :: [v] -> (ValExpr v) -> FuncDef v
instance Control.DeepSeq.NFData v => Control.DeepSeq.NFData (FuncDef.FuncDef v)
instance GHC.Generics.Generic (FuncDef.FuncDef v)
instance GHC.Show.Show v => GHC.Show.Show (FuncDef.FuncDef v)
instance (GHC.Classes.Ord v, GHC.Read.Read v) => GHC.Read.Read (FuncDef.FuncDef v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (FuncDef.FuncDef v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (FuncDef.FuncDef v)
instance (Id.Resettable v, GHC.Classes.Ord v) => Id.Resettable (FuncDef.FuncDef v)


-- | Interface file for Value Expressions.
module ValExpr

-- | ValExpr: value expression
--   
--   <ol>
--   <li>User can't directly construct ValExpr (such that invariants will
--   always hold)</li>
--   <li>User can still pattern match on ValExpr using
--   <a>ValExprView</a></li>
--   <li>Overhead at run-time is zero. See
--   <a>https://wiki.haskell.org/Performance/Data_types#Newtypes</a></li>
--   </ol>
data ValExpr v

-- | View on value expression.
view :: ValExpr v -> ValExprView v

-- | Evaluate the provided value expression. Either the Right Constant
--   Value is returned or a (Left) error message.
eval :: Show v => ValExpr v -> Either String Const

-- | ValExprView: the public view of value expression <a>ValExpr</a>
data ValExprView v
Vconst :: Const -> ValExprView v
Vvar :: v -> ValExprView v
Vequal :: (ValExpr v) -> (ValExpr v) -> ValExprView v
Vite :: ValExpr v -> ValExpr v -> ValExpr v -> ValExprView v
[condition] :: ValExprView v -> ValExpr v
[trueBranch] :: ValExprView v -> ValExpr v
[falseBranch] :: ValExprView v -> ValExpr v
Vnot :: (ValExpr v) -> ValExprView v
Vand :: (Set (ValExpr v)) -> ValExprView v
Vdivide :: ValExpr v -> ValExpr v -> ValExprView v
[dividend] :: ValExprView v -> ValExpr v
[divisor] :: ValExprView v -> ValExpr v
Vmodulo :: ValExpr v -> ValExpr v -> ValExprView v
[dividend] :: ValExprView v -> ValExpr v
[divisor] :: ValExprView v -> ValExpr v
Vsum :: (FreeSum (ValExpr v)) -> ValExprView v
Vproduct :: (FreeProduct (ValExpr v)) -> ValExprView v
Vgez :: (ValExpr v) -> ValExprView v
Vlength :: (ValExpr v) -> ValExprView v
Vat :: ValExpr v -> ValExpr v -> ValExprView v
[string] :: ValExprView v -> ValExpr v
[position] :: ValExprView v -> ValExpr v
Vconcat :: [ValExpr v] -> ValExprView v
Vstrinre :: ValExpr v -> ValExpr v -> ValExprView v
[string] :: ValExprView v -> ValExpr v
[regex] :: ValExprView v -> ValExpr v
Vcstr :: CstrId -> [ValExpr v] -> ValExprView v
Viscstr :: CstrId -> (ValExpr v) -> ValExprView v
Vaccess :: CstrId -> Int -> (ValExpr v) -> ValExprView v
Vfunc :: FuncId -> [ValExpr v] -> ValExprView v
Vpredef :: PredefKind -> FuncId -> [ValExpr v] -> ValExprView v

-- | only needed for CNECTDEF
data PredefKind
AST :: PredefKind
ASF :: PredefKind
AXT :: PredefKind
AXF :: PredefKind
SSB :: PredefKind
SSI :: PredefKind
SSS :: PredefKind

-- | Types that contain values of type <tt>Id</tt> that can be reset (set
--   to zero).
class Resettable e

-- | Create a constant as a value expression.
cstrConst :: Const -> ValExpr v

-- | Create a variable as a value expression.
cstrVar :: v -> ValExpr v

-- | Apply operator Equal on the provided value expressions. Preconditions
--   are <i>not</i> checked.
cstrEqual :: (Ord v) => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator ITE (IF THEN ELSE) on the provided value expressions.
--   Preconditions are <i>not</i> checked.
cstrITE :: Eq v => ValExpr v -> ValExpr v -> ValExpr v -> ValExpr v

-- | Create a function call. Preconditions are <i>not</i> checked.
cstrFunc :: (Variable v, Variable w) => Map FuncId (FuncDef v) -> FuncId -> [ValExpr w] -> ValExpr w

-- | Apply operator Not on the provided value expression. Preconditions are
--   <i>not</i> checked.
cstrNot :: ValExpr v -> ValExpr v

-- | Apply operator And on the provided set of value expressions.
--   Preconditions are <i>not</i> checked.
cstrAnd :: (Ord v) => Set (ValExpr v) -> ValExpr v

-- | Apply operator sum on the provided sum of value expressions.
--   Preconditions are <i>not</i> checked.
cstrSum :: forall v. (Ord v, Integral (ValExpr v)) => FreeSum (ValExpr v) -> ValExpr v

-- | Apply operator product on the provided product of value expressions.
--   Be aware that division is not associative for Integer, so only use
--   power &gt;= 0. Preconditions are <i>not</i> checked.
cstrProduct :: forall v. (Ord v, Integral (ValExpr v)) => FreeProduct (ValExpr v) -> ValExpr v

-- | Apply operator Divide on the provided value expressions. Preconditions
--   are <i>not</i> checked.
cstrDivide :: ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator Modulo on the provided value expressions. Preconditions
--   are <i>not</i> checked.
cstrModulo :: ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator GEZ (Greater Equal Zero) on the provided value
--   expression. Preconditions are <i>not</i> checked.
cstrGEZ :: ValExpr v -> ValExpr v

-- | Apply operator Length on the provided value expression. Preconditions
--   are <i>not</i> checked.
cstrLength :: ValExpr v -> ValExpr v

-- | Apply operator At on the provided value expressions. Preconditions are
--   <i>not</i> checked.
cstrAt :: ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator Concat on the provided sequence of value expressions.
--   Preconditions are <i>not</i> checked.
cstrConcat :: (Eq v) => [ValExpr v] -> ValExpr v

-- | Apply String In Regular Expression operator on the provided value
--   expressions. Preconditions are <i>not</i> checked.
cstrStrInRe :: ValExpr v -> ValExpr v -> ValExpr v

-- | Apply ADT Constructor of constructor with CstrId and the provided
--   arguments (the list of value expressions). Preconditions are
--   <i>not</i> checked.
cstrCstr :: CstrId -> [ValExpr v] -> ValExpr v

-- | Is the provided value expression made by the ADT constructor with
--   CstrId? Preconditions are <i>not</i> checked.
cstrIsCstr :: CstrId -> ValExpr v -> ValExpr v

-- | Apply ADT Accessor of constructor with CstrId on field with given
--   position on the provided value expression. Preconditions are
--   <i>not</i> checked.
cstrAccess :: CstrId -> Int -> ValExpr v -> ValExpr v

-- | Create a call to a predefined function as a value expression.
cstrPredef :: PredefKind -> FuncId -> [ValExpr v] -> ValExpr v

-- | Substitute variables by value expressions in a value expression.
--   
--   Preconditions are <i>not</i> checked.
subst :: (Variable v, Integral (ValExpr v), Variable w, Integral (ValExpr w)) => Map v (ValExpr v) -> Map FuncId (FuncDef w) -> ValExpr v -> ValExpr v

-- | Substitute variables by value expressions in a value expression
--   (change variable kind). Preconditions are <i>not</i> checked.
compSubst :: (Variable v, Integral (ValExpr v), Variable w, Integral (ValExpr w)) => Map v (ValExpr w) -> Map FuncId (FuncDef v) -> ValExpr v -> ValExpr w

-- | Apply operator Or (\/) on the provided set of value expressions.
--   Preconditions are <i>not</i> checked.
cstrOr :: Ord v => Set (ValExpr v) -> ValExpr v

-- | Apply operator Xor (\|/) on the provided set of value expressions.
--   Preconditions are <i>not</i> checked.
cstrXor :: Ord v => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator Implies (=&gt;) on the provided value expressions.
--   Preconditions are <i>not</i> checked.
cstrImplies :: Ord v => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply unary operator Plus on the provided value expression.
--   Preconditions are <i>not</i> checked.
cstrUnaryPlus :: ValExpr v -> ValExpr v

-- | Apply unary operator Minus on the provided value expression.
--   Preconditions are <i>not</i> checked.
cstrUnaryMinus :: Ord v => ValExpr v -> ValExpr v

-- | Apply operator Add on the provided value expressions. Preconditions
--   are <i>not</i> checked.
cstrPlus :: Ord v => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator Minus on the provided value expressions. Preconditions
--   are <i>not</i> checked.
cstrMinus :: Ord v => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator Times on the provided value expressions. Preconditions
--   are <i>not</i> checked.
cstrTimes :: Ord v => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator Absolute value (abs) on the provided value expression.
--   Preconditions are <i>not</i> checked.
cstrAbs :: Ord v => ValExpr v -> ValExpr v

-- | Apply operator LT (&lt;) on the provided value expression.
--   Preconditions are <i>not</i> checked.
cstrLT :: Ord v => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator LE (&lt;=) on the provided value expression.
--   Preconditions are <i>not</i> checked.
cstrLE :: Ord v => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator GE (&gt;=) on the provided value expression.
--   Preconditions are <i>not</i> checked.
cstrGE :: Ord v => ValExpr v -> ValExpr v -> ValExpr v

-- | Apply operator GT (&gt;) on the provided value expression.
--   Preconditions are <i>not</i> checked.
cstrGT :: Ord v => ValExpr v -> ValExpr v -> ValExpr v
