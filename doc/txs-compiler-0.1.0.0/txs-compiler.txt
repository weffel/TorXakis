-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package txs-compiler
@version 0.1.0.0


-- | Compiler error type and associated functions.
module TorXakis.Compiler.Error

-- | Simple error type.
data Error

-- | Single error.
Error :: ErrorType -> ErrorLoc -> Text -> Error
[_errorType] :: Error -> ErrorType
[_errorLoc] :: Error -> ErrorLoc
[_errorMsg] :: Error -> Text

-- | Multiple errors.
Errors :: [Error] -> Error
errorLoc :: Traversal' Error ErrorLoc
errorMsg :: Traversal' Error Text
errorType :: Traversal' Error ErrorType

-- | Type of errors that can occur when compiling a <tt>TorXakis</tt> model
--   file.
data ErrorType
ParseError :: ErrorType
TypeMismatch :: ErrorType

-- | An entity was not defined.
Undefined :: Entity -> ErrorType

-- | Multiple definitions for the same entity.
MultipleDefinitions :: Entity -> ErrorType

-- | An entity could not be resolved (based on the type information for
--   instance).
Unresolved :: Entity -> ErrorType

-- | An entity has multiple candidates (based on the type information for
--   instance)
Ambiguous :: Entity -> ErrorType

-- | An entity is missing from the declaration.
Missing :: Entity -> ErrorType

-- | No definition found for function or process.
NoDefinition :: ErrorType
InvalidExpression :: ErrorType

-- | An error in the compiler has happened.
CompilerPanic :: ErrorType

-- | Entity to which the error is related.
data Entity
Function :: Entity
Process :: Entity
InitialState :: Entity
State :: Entity
Variable :: Entity
Sort :: Entity

-- | In case an error must be generated from a generic function that cannot
--   have access to the entity type. The error type can be made more
--   specific by the caller of such a generic function (see for instance
--   <tt>getUniqueElement</tt>).
Entity :: Entity

-- | Location of an error.
data ErrorLoc

-- | The error location could not be determined. By adding location to
--   TorXakis core types like <tt>SortId</tt> it is possible to augment the
--   number of places in which errors can be associated to locations.
NoErrorLoc :: ErrorLoc

-- | The error is related to a pre-defined entity.
ErrorPredef :: Text -> ErrorLoc
ErrorLoc :: Int -> Int -> ErrorLoc
[errorLine] :: ErrorLoc -> Int
[errorColumn] :: ErrorLoc -> Int

-- | Entities that have an error location.
class HasErrorLoc l
getErrorLoc :: HasErrorLoc l => l -> ErrorLoc
getErrorLoc :: HasErrorLoc l => l -> ErrorLoc
instance GHC.Show.Show TorXakis.Compiler.Error.Error
instance GHC.Classes.Eq TorXakis.Compiler.Error.Error
instance GHC.Show.Show TorXakis.Compiler.Error.ErrorLoc
instance GHC.Classes.Eq TorXakis.Compiler.Error.ErrorLoc
instance GHC.Show.Show TorXakis.Compiler.Error.ErrorType
instance GHC.Classes.Eq TorXakis.Compiler.Error.ErrorType
instance GHC.Show.Show TorXakis.Compiler.Error.Entity
instance GHC.Classes.Eq TorXakis.Compiler.Error.Entity


module TorXakis.Compiler.Data
data CompilerM a

-- | Run the compiler.
runCompiler :: CompilerM a -> StateT St (Either Error) a

-- | State of the compiler.
data St

-- | Create a new state. The start value for identifiers will be '1000' for
--   compatibility with the current <tt>TorXakis</tt> compiler.
newState :: St

-- | Get the value of the unique id counter.
getUnid :: CompilerM Int

-- | Set the unique id counter to the given value.
setUnid :: Int -> CompilerM ()

-- | Get the next unique id, and increment the unique id counter in the
--   compiler state.
getNextId :: CompilerM Int

-- | Like traverse, but catch and error and continue if any
--   <a>CompilerM</a> action throws an error in the process.
traverseCatch :: (a -> CompilerM b) -> [a] -> CompilerM ([(a, Error)], [b])

-- | Flipped version of traverseCatch
forCatch :: [a] -> (a -> CompilerM b) -> CompilerM ([(a, Error)], [b])
instance Control.Monad.Error.Class.MonadError TorXakis.Compiler.Error.Error TorXakis.Compiler.Data.CompilerM
instance Control.Monad.State.Class.MonadState TorXakis.Compiler.Data.St TorXakis.Compiler.Data.CompilerM
instance GHC.Base.Monad TorXakis.Compiler.Data.CompilerM
instance GHC.Base.Applicative TorXakis.Compiler.Data.CompilerM
instance GHC.Base.Functor TorXakis.Compiler.Data.CompilerM
instance GHC.Show.Show TorXakis.Compiler.Data.St
instance GHC.Classes.Eq TorXakis.Compiler.Data.St


-- | Definition for the <a>MapsTo</a> class, and associated operators.
--   
--   A constraint of the form 'MapsTo k v mm' denotes that <tt>mm</tt>
--   contains a map from keys of type <tt>k</tt> to values of type
--   <tt>t</tt>.
module TorXakis.Compiler.MapsTo

-- | <tt>mm</tt> maps keys of type <tt>k</tt> onto values of type
--   <tt>v</tt>. The type <tt>mm</tt> can be thought as a composite map,
--   which contains multiple maps. See <tt>:&amp;</tt> for more details.
class (In (k, v) (Contents mm) ~  'True) => MapsTo k v mm

-- | Lookup a key in the map.
lookup :: (MapsTo k v mm, Ord k, Show k, Typeable k, Typeable v) => k -> mm -> Either Error v

-- | Monadic version of <tt>lookup</tt>.
lookupM :: (MapsTo k v mm, Ord k, Show k, Typeable k, Typeable v) => k -> mm -> CompilerM v

-- | Get the inner map.
innerMap :: MapsTo k v mm => mm -> Map k v

-- | Add a map. The addition is biased towards the new map. If the two maps
--   have the same key, then the value of the right map is discarded, and
--   the value of the left map is kept.
(<.+>) :: (MapsTo k v mm, Ord k) => Map k v -> mm -> mm

-- | Replace the inner map with the given one.
replaceInnerMap :: MapsTo k v mm => mm -> Map k v -> mm

-- | Compute when a type is in a tree.

-- | Type family that represents the contents of a map.

-- | Lookup a key in the map.
lookup :: (MapsTo k v mm, Ord k, Show k, Typeable k, Typeable v) => k -> mm -> Either Error v

-- | Monadic version of <tt>lookup</tt>.
lookupM :: (MapsTo k v mm, Ord k, Show k, Typeable k, Typeable v) => k -> mm -> CompilerM v

-- | Get all the keys of type <tt>k</tt> that are associated to values of
--   type <tt>v</tt> in the given map.
keys :: forall k v mm. MapsTo k v mm => mm -> [k]

-- | Get all the values of type <tt>v</tt> that are associated to keys of
--   type <tt>k</tt> in the given map.
values :: forall k v mm. MapsTo k v mm => mm -> [v]

-- | Get the inner map.
innerMap :: MapsTo k v mm => mm -> Map k v

-- | Combinator for maps.
data a (:&) b
(:&) :: a -> b -> (:&) a b

-- | Add a map. The addition is biased towards the new map. If the two maps
--   have the same key, then the value of the right map is discarded, and
--   the value of the left map is kept.
(<.+>) :: (MapsTo k v mm, Ord k) => Map k v -> mm -> mm
infixl 4 <.+>

-- | Like <tt><a>.+</a></tt> but its left argument is a list instead of a
--   map. Useful when we want to add a list to a composite map.
(<.++>) :: (Ord k, MapsTo k v mm) => [(k, v)] -> mm -> mm
infixr 6 <.++>

-- | Combine a list of key values pairs with an existing map.
(.&) :: (Ord k0) => [(k0, v0)] -> mm -> Map k0 v0 :& mm
infixr 6 .&

-- | Combine lists of key values pairs into a pair of maps.
(.&.) :: (Ord k0, Ord k1) => [(k0, v0)] -> [(k1, v1)] -> Map k0 v0 :& Map k1 v1
infixr 6 .&.

-- | Replace the inner map with the given one.
replaceInnerMap :: MapsTo k v mm => mm -> Map k v -> mm
instance (TorXakis.Compiler.MapsTo.MapsTo k v m0, TorXakis.Compiler.MapsTo.In (k, v) (TorXakis.Compiler.MapsTo.Contents m1) ~ 'GHC.Types.False) => TorXakis.Compiler.MapsTo.PairMapsTo k v m0 m1 'GHC.Types.True 'GHC.Types.False
instance (TorXakis.Compiler.MapsTo.In (k, v) (TorXakis.Compiler.MapsTo.Contents m0) ~ 'GHC.Types.False, TorXakis.Compiler.MapsTo.MapsTo k v m1) => TorXakis.Compiler.MapsTo.PairMapsTo k v m0 m1 'GHC.Types.False 'GHC.Types.True
instance TorXakis.Compiler.MapsTo.PairMapsTo k v m0 m1 inM0 inM1 => TorXakis.Compiler.MapsTo.MapsTo k v (m0 TorXakis.Compiler.MapsTo.:& m1)
instance ((TypeError ...), TorXakis.Compiler.MapsTo.In (k, v) (TorXakis.Compiler.MapsTo.Contents m0) ~ 'GHC.Types.False, TorXakis.Compiler.MapsTo.In (k, v) (TorXakis.Compiler.MapsTo.Contents m1) ~ 'GHC.Types.False, 'GHC.Types.False ~ 'GHC.Types.True) => TorXakis.Compiler.MapsTo.PairMapsTo k v m0 m1 'GHC.Types.False 'GHC.Types.False
instance ((TypeError ...), TorXakis.Compiler.MapsTo.In (k, v) (TorXakis.Compiler.MapsTo.Contents m0) ~ 'GHC.Types.True, TorXakis.Compiler.MapsTo.In (k, v) (TorXakis.Compiler.MapsTo.Contents m1) ~ 'GHC.Types.True) => TorXakis.Compiler.MapsTo.PairMapsTo k v m0 m1 'GHC.Types.True 'GHC.Types.True
instance TorXakis.Compiler.MapsTo.MapsTo k v (Data.Map.Internal.Map k v)


-- | <tt>TorXakis</tt> expressions that can be simplified.
module TorXakis.Compiler.Simplifiable

-- | Simplify the expressions by applying the functions defined in the
--   function table.
simplify :: Simplifiable e => FuncTable VarId -> [Text] -> e -> e
instance TorXakis.Compiler.Simplifiable.Simplifiable (ValExprDefs.ValExpr VarId.VarId)
instance TorXakis.Compiler.Simplifiable.Simplifiable FuncId.FuncId
instance TorXakis.Compiler.Simplifiable.Simplifiable ModelId.ModelId
instance TorXakis.Compiler.Simplifiable.Simplifiable MapperId.MapperId
instance TorXakis.Compiler.Simplifiable.Simplifiable (FuncDef.FuncDef VarId.VarId)
instance (TorXakis.Compiler.Simplifiable.Simplifiable a, TorXakis.Compiler.Simplifiable.Simplifiable b) => TorXakis.Compiler.Simplifiable.Simplifiable (a, b)
instance TorXakis.Compiler.Simplifiable.Simplifiable a => TorXakis.Compiler.Simplifiable.Simplifiable [a]
instance (TorXakis.Compiler.Simplifiable.Simplifiable a, GHC.Classes.Ord a) => TorXakis.Compiler.Simplifiable.Simplifiable (Data.Set.Internal.Set a)
instance (TorXakis.Compiler.Simplifiable.Simplifiable k, TorXakis.Compiler.Simplifiable.Simplifiable v, GHC.Classes.Ord k) => TorXakis.Compiler.Simplifiable.Simplifiable (Data.Map.Internal.Map k v)
instance TorXakis.Compiler.Simplifiable.Simplifiable ProcId.ProcId
instance TorXakis.Compiler.Simplifiable.Simplifiable ProcDef.ProcDef
instance TorXakis.Compiler.Simplifiable.Simplifiable ModelDef.ModelDef
instance TorXakis.Compiler.Simplifiable.Simplifiable MapperDef.MapperDef
instance TorXakis.Compiler.Simplifiable.Simplifiable BehExprDefs.BExpr
instance TorXakis.Compiler.Simplifiable.Simplifiable BehExprDefs.ActOffer
instance TorXakis.Compiler.Simplifiable.Simplifiable BehExprDefs.Offer
instance TorXakis.Compiler.Simplifiable.Simplifiable BehExprDefs.ChanOffer
instance TorXakis.Compiler.Simplifiable.Simplifiable VarId.VarId
instance TorXakis.Compiler.Simplifiable.Simplifiable BehExprDefs.Trans
instance TorXakis.Compiler.Simplifiable.Simplifiable PurpId.PurpId
instance TorXakis.Compiler.Simplifiable.Simplifiable PurpDef.PurpDef
instance TorXakis.Compiler.Simplifiable.Simplifiable GoalId.GoalId
instance TorXakis.Compiler.Simplifiable.Simplifiable CnectId.CnectId
instance TorXakis.Compiler.Simplifiable.Simplifiable CnectDef.CnectDef
instance TorXakis.Compiler.Simplifiable.Simplifiable ConnectionDefs.ConnDef
instance (GHC.Classes.Ord a, TorXakis.Compiler.Simplifiable.Simplifiable a) => TorXakis.Compiler.Simplifiable.Simplifiable (FreeMonoidX.FreeMonoidX a)
instance TorXakis.Compiler.Simplifiable.Simplifiable a => TorXakis.Compiler.Simplifiable.Simplifiable (Sum.SumTerm a)
instance TorXakis.Compiler.Simplifiable.Simplifiable a => TorXakis.Compiler.Simplifiable.Simplifiable (Product.ProductTerm a)


-- | Abstract syntax trees for the <tt>TorXakis</tt> parser and compiler.
module TorXakis.Parser.Data

-- | State of the parser.
data St

-- | Create anew state.
mkState :: Int -> St
nodeLoc :: ParseTree t c -> Loc t
nodeType :: ParseTree t c -> t

-- | Increment the id of the state.
incId :: St -> St
nextId :: St -> Int

-- | Location associated to the elements being parsed.
data Loc t
Loc :: Int -> Int -> Int -> Loc t

-- | Line in which a declaration occurs.
[line] :: Loc t -> Int

-- | Start column.
[start] :: Loc t -> Int

-- | Unique identifier.
[locUid] :: Loc t -> Int
PredefLoc :: Text -> Int -> Loc t

-- | Name of the predefined location
[locName] :: Loc t -> Text

-- | Unique identifier.
[locUid] :: Loc t -> Int
ExtraAut :: Text -> (Loc t) -> Loc t

-- | Change extract the location of the metadata, and change its type from
--   <tt>t</tt> to <tt>u</tt>. This is useful when defining parsed entities
--   whose locations coincide, like expressions and variable-references or
--   constant-literals.
locFromLoc :: Loc t -> Loc u

-- | Class of entities that have a location associated to them.
class HasLoc a t | a -> t

-- | Get the location of the entity.
getLoc :: HasLoc a t => a -> Loc t

-- | Location lens.
loc' :: HasLoc a t => Lens' a (Loc t)

-- | Entities that are variables.
class IsVariable v

-- | Name of a variable.
varName :: IsVariable v => v -> Text

-- | Name of an entity.
data Name t
toText :: Name t -> Text

-- | ADT.
data ADTE

-- | Constructor.
data CstrE

-- | Field of a constructor.
data FieldE

-- | Reference to an existing (previously defined or primitive) sort.
data SortRefE

-- | Function declaration.
data FuncDeclE

-- | A variable declaration.
data VarDeclE

-- | An expression
data ExpDeclE

-- | A variable occurrence in an expression. It is assumed to be a
--   **reference** to an existing variable.
data VarRefE

-- | Channel declaration.
data ChanDeclE

-- | Channel reference.
data ChanRefE

-- | Process declaration.
data ProcDeclE

-- | State automaton declaration.
data StautDeclE

-- | State declaration.
data StateDeclE

-- | Reference to a state.
data StateRefE

-- | Purpose declaration.
data PurpDeclE

-- | Goal declaration.
data GoalDeclE

-- | Connect declaration.
data CnectDeclE

-- | Action prefix.
data ActPrefE
type ADTDecl = ParseTree ADTE [CstrDecl]

-- | Make an ADT declaration.
mkADTDecl :: Text -> Loc ADTE -> [CstrDecl] -> ADTDecl

-- | Name of the ADT declaration.
adtName :: ADTDecl -> Text

-- | Constructors of the ADT.
constructors :: ADTDecl -> [CstrDecl]

-- | ADT constructor declaration.
type CstrDecl = ParseTree CstrE [FieldDecl]

-- | Make a constructor declaration.
mkCstrDecl :: Text -> Loc CstrE -> [FieldDecl] -> CstrDecl

-- | Name of the constructor.
cstrName :: CstrDecl -> Text

-- | Fields of the constructor.
cstrFields :: CstrDecl -> [FieldDecl]

-- | Field declarations.
type FieldDecl = ParseTree FieldE OfSort

-- | Make a field declaration.
mkFieldDecl :: Text -> Loc FieldE -> OfSort -> FieldDecl

-- | Name of the field declaration.
fieldName :: FieldDecl -> Text

-- | Get the field of a sort, and the metadata associated to it.
fieldSort :: FieldDecl -> (Text, Loc SortRefE)

-- | Reference to an existing type
type OfSort = ParseTree SortRefE ()

-- | Make a declaration of an entity belonging to a sort.
mkOfSort :: Text -> Loc SortRefE -> OfSort

-- | Name of the sort reference.
sortRefName :: OfSort -> Text

-- | Function declarations.
type FuncDecl = ParseTree FuncDeclE FuncComps

-- | Make a function declaration.
mkFuncDecl :: Text -> Loc FuncDeclE -> [VarDecl] -> OfSort -> ExpDecl -> FuncDecl

-- | Name of the function declaration.
funcName :: FuncDecl -> Text

-- | Function parameters.
funcParams :: FuncDecl -> [VarDecl]

-- | Function body,
funcBody :: FuncDecl -> ExpDecl

-- | Return sort of a function.
funcRetSort :: FuncDecl -> (Text, Loc SortRefE)

-- | Variable declarations (with an explicit sort).
type VarDecl = ParseTree VarDeclE OfSort

-- | Make a variable declaration.
mkVarDecl :: Text -> Loc VarDeclE -> OfSort -> VarDecl

-- | Sort of a variable declaration.
varDeclSort :: VarDecl -> (Text, Loc SortRefE)

-- | Implicit variable declaration (maybe with a sort associated to it).
type IVarDecl = ParseTree VarDeclE (Maybe OfSort)

-- | Make an implicit variable declaration, which might have an optional
--   type associated to it.
mkIVarDecl :: Text -> Loc VarDeclE -> Maybe OfSort -> IVarDecl
ivarDeclSort :: IVarDecl -> Maybe OfSort

-- | Variable references.
type VarRef = ParseTree VarRefE ()

-- | Make a variable reference.
mkVarRef :: Text -> Loc VarRefE -> VarRef

-- | Name of a variable.
varName :: IsVariable v => v -> Text

-- | Declaration of an expression.
type ExpDecl = ParseTree ExpDeclE ExpChild
data ExpChild
VarRef :: (Name VarRefE) -> (Loc VarRefE) -> ExpChild
ConstLit :: Const -> ExpChild

-- | A let expression allows to introduce a series of value bindings of the
--   form:
--   
--   <pre>
--   x0 = v0, ..., xn = vn
--   </pre>
--   
--   A let expression contains a list of lists that have the form above.
--   Values declared within one '[LetVarDecl]' list introduce variable
--   names in parallel (in the sense that one variable in the list cannot
--   be used in the expressions within that list). However, values declared
--   in '[LetVarDecl]' lists can be used in subsequent '[LetVarDecl]'
--   lists. For instance, the following let expression:
--   
--   <pre>
--   LET x = 1, y = 5; z = x + y IN ...
--   </pre>
--   
--   Will be parsed to the following list
--   
--   <pre>
--   [[(x, 1), (y, 5)], [(z, x + y)]]
--   </pre>
--   
--   Here <tt>x</tt> and <tt>y</tt> cannot be used in the expressions of
--   the first list, but it can be used in the expressions of the second.
LetExp :: [ParLetVarDecl] -> ExpDecl -> ExpChild
If :: ExpDecl -> ExpDecl -> ExpDecl -> ExpChild

-- | Function application. A function is applied to a list of expressions.
Fappl :: (Name VarRefE) -> (Loc VarRefE) -> [ExpDecl] -> ExpChild

-- | Constant declarations.
data Const
BoolConst :: Bool -> Const
IntConst :: Integer -> Const
StringConst :: Text -> Const
RegexConst :: Text -> Const
AnyConst :: Const

-- | Child of an expression.
expChild :: ExpDecl -> ExpChild

-- | Get the child-expressions of an expression.
childExps :: ExpDecl -> [ExpDecl]

-- | Make a variable expression. The location of the expression will become
--   the location of the variable.
mkVarExp :: Loc ExpDeclE -> Text -> ExpDecl

-- | Make a Boolean constant expression.
mkBoolConstExp :: Loc ExpDeclE -> Bool -> ExpDecl

-- | Make an integer constant expression.
mkIntConstExp :: Loc ExpDeclE -> Integer -> ExpDecl

-- | Make a string constant expression.
mkStringConstExp :: Loc ExpDeclE -> Text -> ExpDecl

-- | Make a regex constant expression.
mkRegexConstExp :: Loc ExpDeclE -> Text -> ExpDecl

-- | Make a let-expression declaration.
mkLetExpDecl :: [ParLetVarDecl] -> ExpDecl -> Loc ExpDeclE -> ExpDecl

-- | Make an if-then-else expression declaration.
mkITEExpDecl :: Loc ExpDeclE -> ExpDecl -> ExpDecl -> ExpDecl -> ExpDecl

-- | Make a function-application expression declaration.
mkFappl :: Loc ExpDeclE -> Loc VarRefE -> Text -> [ExpDecl] -> ExpDecl

-- | Make a let variable declaration.
mkLetVarDecl :: Text -> Maybe OfSort -> ExpDecl -> Loc VarDeclE -> LetVarDecl

-- | Extract all the let-variable declarations of an expression.
expLetVarDecls :: ExpDecl -> [[LetVarDecl]]

-- | Let-variable declarations.
type LetVarDecl = ParseTree VarDeclE (Maybe OfSort, ExpDecl)

-- | Expression declaration in a let-variable declaration.
varDeclExp :: LetVarDecl -> ExpDecl

-- | Sort name of a let-variable declaration.
letVarDeclSortName :: LetVarDecl -> Maybe (Text, Loc SortRefE)

-- | Parallel let-variable declarations.
newtype ParLetVarDecl
ParLetVarDecl :: [LetVarDecl] -> ParLetVarDecl

-- | Model declaration.
type ModelDecl = ParseTree ModelDeclE ModelComps

-- | Make a model declaration.
mkModelDecl :: Text -> Loc ModelDeclE -> [ChanRef] -> [ChanRef] -> Maybe [Set ChanRef] -> BExpDecl -> ModelDecl

-- | Name of the model.
modelName :: ModelDecl -> Text

-- | Model input channels.
modelIns :: ModelDecl -> [ChanRef]

-- | Model output channels.
modelOuts :: ModelDecl -> [ChanRef]

-- | Model synchronization channels.
modelSyncs :: ModelDecl -> Maybe [Set ChanRef]

-- | Model behavior expressions.
modelBExp :: ModelDecl -> BExpDecl

-- | Behavior expression declaration.
data BExpDecl

-- | <tt>STOP</tt> operator.
Stop :: BExpDecl

-- | <tt>&gt;-&gt;</tt> (action prefix) operator.
ActPref :: (Loc ActPrefE) -> ActOfferDecl -> BExpDecl -> BExpDecl

-- | <tt>LET</tt> declarations for behavior expressions.
LetBExp :: [ParLetVarDecl] -> BExpDecl -> BExpDecl

-- | Process instantiation.
Pappl :: (Name ProcRefE) -> (Loc ProcRefE) -> [ChanRef] -> [ExpDecl] -> BExpDecl

-- | Parallel operators.
Par :: (Loc ParOpE) -> SyncOn -> BExpDecl -> BExpDecl -> BExpDecl

-- | Enable operator.
Enable :: (Loc EnableE) -> BExpDecl -> BExpDecl -> BExpDecl

-- | <tt>ACCEPT</tt> operator.
--   
--   Note that while the parser will allow <tt>ACCEPT</tt>s in arbitrary
--   positions, the compiler will check that they only occur after an
--   enable operator (<tt>&gt;&gt;&gt;</tt>)
Accept :: (Loc AcceptE) -> [ChanOfferDecl] -> BExpDecl -> BExpDecl

-- | Disable operator.
Disable :: (Loc DisableE) -> BExpDecl -> BExpDecl -> BExpDecl

-- | Interrupt operator.
Interrupt :: (Loc InterruptE) -> BExpDecl -> BExpDecl -> BExpDecl

-- | Choice operator.
Choice :: (Loc ChoiceE) -> BExpDecl -> BExpDecl -> BExpDecl

-- | Guard operator.
Guard :: ExpDecl -> BExpDecl -> BExpDecl

-- | Hide operator.
Hide :: (Loc HideE) -> [ChanDecl] -> BExpDecl -> BExpDecl

-- | Action offer declaration.
data ActOfferDecl
ActOfferDecl :: [OfferDecl] -> Maybe ExpDecl -> ActOfferDecl
[_offers] :: ActOfferDecl -> [OfferDecl]
[_constraint] :: ActOfferDecl -> Maybe ExpDecl

-- | Offer declaration.
data OfferDecl
OfferDecl :: ChanRef -> [ChanOfferDecl] -> OfferDecl

-- | Channel offer declarations.
--   
--   Note that a receiving action with an explicit type declaration are
--   only needed to simplify the type inference of exit variables used in
--   expressions of the form 'EXIT ? v :: T'.
data ChanOfferDecl
QuestD :: IVarDecl -> ChanOfferDecl
ExclD :: ExpDecl -> ChanOfferDecl

-- | Channels to sync on in a parallel operator.
data SyncOn

-- | Sync on all channels, this is the result of parsing <a>||</a>
All :: SyncOn

-- | Sync only on the given channels. This is the result of parsing either
--   <tt>|||</tt> or '|[...]|'. Parsing <tt>|||</tt> will result in an
--   empty list, meaning that full interleaving is allowed.
OnlyOn :: [ChanRef] -> SyncOn

-- | Implicit variable (if any) of a channel offer declaration.
chanOfferIvarDecl :: ChanOfferDecl -> Maybe IVarDecl

-- | Get all the variable declarations introduced by receiving actions of
--   the form 'Ch ? v'.
actOfferDecls :: ActOfferDecl -> [IVarDecl]

-- | Get the implicit variable declarations of an offer declaration.
offerDecls :: OfferDecl -> [IVarDecl]

-- | Reference to a channel in an offer declaration.
chanRefOfOfferDecl :: OfferDecl -> ChanRef

-- | Implicit variable declarations of a channel offer.
chanOfferDecls :: ChanOfferDecl -> [IVarDecl]

-- | Transform the location of a variable declaration into the location of
--   a variable reference. A variable declaration refers to itself.
--   
--   We do not want to export <tt>locFromLoc</tt> since we will be loosing
--   the type-guarantees offered by the phantom type. By having
--   <tt>locFromLoc</tt> private to this module we are in control of which
--   conversions are allowed.
asVarReflLoc :: Loc VarDeclE -> Loc VarRefE

-- | Channel declaration.
type ChanDecl = ParseTree ChanDeclE [OfSort]

-- | Make a channel declaration.
mkChanDecl :: Text -> Loc ChanDeclE -> [OfSort] -> ChanDecl

-- | Name of the channel declaration.
chanDeclName :: ChanDecl -> Text

-- | Sorts of a channel declaration with their locations, which can be used
--   for lookup and error reporting.
chanDeclSorts :: ChanDecl -> [(Text, Loc SortRefE)]

-- | Channel references.
type ChanRef = ParseTree ChanRefE ()

-- | Make a channel reference.
mkChanRef :: Text -> Loc ChanRefE -> ChanRef

-- | Name of the channel reference.
chanRefName :: ChanRef -> Text

-- | Process declaration.
type ProcDecl = ParseTree ProcDeclE ProcComps

-- | Make a process declaration.
mkProcDecl :: Text -> Loc ProcDeclE -> [ChanDecl] -> [VarDecl] -> ExitSortDecl -> BExpDecl -> ProcDecl

-- | Name of a process declaration.
procDeclName :: ProcDecl -> Text

-- | Components of a process declaration.
procDeclComps :: ProcDecl -> ProcComps

-- | Body of a process declaration.
procDeclBody :: ProcDecl -> BExpDecl

-- | Return sort of a process declaration.
procDeclRetSort :: ProcDecl -> ExitSortDecl

-- | Parameters of a process declaration.
procDeclChParams :: ProcDecl -> [ChanDecl]

-- | Parameters of a process declaration.
procDeclParams :: ProcDecl -> [VarDecl]

-- | Components of a process.
data ProcComps
procChParams :: ProcComps -> [ChanDecl]
procParams :: ProcComps -> [VarDecl]
procRetSort :: ProcComps -> ExitSortDecl
procBody :: ProcComps -> BExpDecl

-- | Process reference name.
procRefName :: Text -> Name ProcRefE

-- | Possible exit sorts of a process.
data ExitSortDecl
NoExitD :: ExitSortDecl
ExitD :: [OfSort] -> ExitSortDecl
HitD :: ExitSortDecl

-- | State automaton declaration.
type StautDecl = ParseTree StautDeclE StautComps

-- | Item of a state automaton.
data StautItem
States :: [StateDecl] -> StautItem
StVarDecl :: [VarDecl] -> StautItem
InitState :: InitStateDecl -> StautItem
Trans :: [Transition] -> StautItem

-- | Declaration of an automaton state.
type StateDecl = ParseTree StateDeclE ()

-- | Reference to a previously declared automaton state.
type StateRef = ParseTree StateRefE ()

-- | State automaton update.
data StUpdate
StUpdate :: [VarRef] -> ExpDecl -> StUpdate

-- | State automaton transition.
data Transition
Transition :: StateRef -> ActOfferDecl -> [StUpdate] -> StateRef -> Transition

-- | Make a state automaton declaration.
mkStautDecl :: Text -> Loc StautDeclE -> [ChanDecl] -> [VarDecl] -> ExitSortDecl -> [StautItem] -> StautDecl

-- | Make a state declaration.
mkStateDecl :: Text -> Loc StateDeclE -> StateDecl

-- | Name the state declaration.
stateDeclName :: StateDecl -> Text

-- | Make a state reference.
mkStateRef :: Text -> Loc StateRefE -> StateRef

-- | Name of the state reference.
stateRefName :: StateRef -> Text

-- | Name of the state automaton.
stautName :: StautDecl -> Text

-- | Return the location of a state automaton as the location of a process
--   declaration.
asProcDeclLoc :: StautDecl -> Loc ProcDeclE

-- | Get the channel declarations of a state automaton.
stautDeclChParams :: StautDecl -> [ChanDecl]

-- | Get the formal parameters of a state automaton.
stautDeclParams :: StautDecl -> [VarDecl]

-- | Get the return sort of a state automaton.
stautDeclRetSort :: StautDecl -> ExitSortDecl

-- | Get the components of a state automaton.
stautDeclComps :: StautDecl -> [StautItem]

-- | Extract the states declared in the automaton.
stautDeclStates :: StautDecl -> [StateDecl]

-- | Extract the variables declared in the automaton.
stautDeclInnerVars :: StautDecl -> [VarDecl]

-- | Extract the initial states declared in the automaton.
stautInitStates :: StautDecl -> [InitStateDecl]

-- | Extract the transitions declared in the automaton.
stautTrans :: StautDecl -> [Transition]

-- | Declaration of an initial state.
data InitStateDecl
InitStateDecl :: StateRef -> [StUpdate] -> InitStateDecl

-- | Make an initial state declaration.
mkInitState :: StateRef -> [StUpdate] -> StautItem

-- | Purpose declaration.
type PurpDecl = ParseTree PurpDeclE PurpComps

-- | Make a purpose declaration.
mkPurpDecl :: Text -> Loc PurpDeclE -> [ChanRef] -> [ChanRef] -> Maybe [Set ChanRef] -> [TestGoalDecl] -> PurpDecl

-- | Components of a purpose.
data PurpComps
PurpComps :: [ChanRef] -> [ChanRef] -> Maybe [Set ChanRef] -> [TestGoalDecl] -> PurpComps
[purpIns] :: PurpComps -> [ChanRef]
[purpOuts] :: PurpComps -> [ChanRef]
[purpSyncs] :: PurpComps -> Maybe [Set ChanRef]
[goals] :: PurpComps -> [TestGoalDecl]

-- | Name of the purpose declaration.
purpDeclName :: PurpDecl -> Text

-- | Input channels of a purpose declaration.
purpDeclIns :: PurpDecl -> [ChanRef]

-- | Output channels of a purpose declaration.
purpDeclOuts :: PurpDecl -> [ChanRef]

-- | Synchronization channels of a purpose declaration.
purpDeclSyncs :: PurpDecl -> Maybe [Set ChanRef]

-- | Goals of a purpose declaration.
purpDeclGoals :: PurpDecl -> [TestGoalDecl]

-- | Declaration of a test goal.
type TestGoalDecl = ParseTree GoalDeclE BExpDecl

-- | Make a test goal declaration.
mkTestGoalDecl :: Text -> Loc GoalDeclE -> BExpDecl -> TestGoalDecl

-- | Name of a test goal declaration.
testGoalDeclName :: TestGoalDecl -> Text

-- | Behavior expression of a test goal declaration.
testGoalDeclBExp :: TestGoalDecl -> BExpDecl

-- | <tt>CNECTDEF</tt> declaration.
type CnectDecl = ParseTree CnectDeclE (CnectType, [CnectItem], [CodecItem])

-- | Connect type declaration.
data CnectType
CTClient :: CnectType
CTServer :: CnectType

-- | Connect item declaration.
data CnectItem
CnectItem :: ChanRef -> CnectItemType -> Text -> Integer -> CnectItem
[cnectCh] :: CnectItem -> ChanRef
[cnectType] :: CnectItem -> CnectItemType
[host] :: CnectItem -> Text
[port] :: CnectItem -> Integer

-- | Type of the connect item.
data CnectItemType
ChanIn :: CnectItemType
ChanOut :: CnectItemType

-- | Codec item declaration.
data CodecItem
CodecItem :: OfferDecl -> ChanOfferDecl -> CodecType -> CodecItem
[codecOffer] :: CodecItem -> OfferDecl
[codecChOffer] :: CodecItem -> ChanOfferDecl
[codecType] :: CodecItem -> CodecType

-- | Type of the codec item.
data CodecType
Decode :: CodecType
Encode :: CodecType

-- | Make a connect declaration.
mkCnectDecl :: Text -> Loc CnectDeclE -> CnectType -> [CnectItem] -> [CodecItem] -> CnectDecl

-- | Name of the connect declaration.
cnectDeclName :: CnectDecl -> Text

-- | Type of the connect declaration.
cnectDeclType :: CnectDecl -> CnectType

-- | Connect items of the connect declaration.
cnectDeclCnectItems :: CnectDecl -> [CnectItem]

-- | Codec items of the connect declaration.
cnectDeclCodecs :: CnectDecl -> [CodecItem]

-- | Mapper declaration.
type MapperDecl = ParseTree MapperDeclE ModelComps

-- | Mapper declaration.
data MapperDeclE

-- | Make a mapper declaration.
mkMapperDecl :: Text -> Loc MapperDeclE -> [ChanRef] -> [ChanRef] -> Maybe [Set ChanRef] -> BExpDecl -> MapperDecl

-- | Name of the mapper.
mapperName :: MapperDecl -> Text

-- | Input channels of the mapper declaration.
mapperIns :: MapperDecl -> [ChanRef]

-- | Output channels of the mapper declaration.
mapperOuts :: MapperDecl -> [ChanRef]

-- | Synchronization channels of the mapper declaration.
mapperSyncs :: MapperDecl -> Maybe [Set ChanRef]

-- | Behavior expression of the mapper declaration.
mapperBExp :: MapperDecl -> BExpDecl

-- | Get the location of the entity.
getLoc :: HasLoc a t => a -> Loc t

-- | Location lens.
loc' :: HasLoc a t => Lens' a (Loc t)

-- | TorXakis definitions generated by the parser.
data ParsedDefs
adts :: Lens' ParsedDefs [ADTDecl]
funcs :: Lens' ParsedDefs [FuncDecl]
consts :: Lens' ParsedDefs [FuncDecl]
models :: Lens' ParsedDefs [ModelDecl]
chdecls :: Lens' ParsedDefs [ChanDecl]
procs :: Lens' ParsedDefs [ProcDecl]

-- | Empty parsed definitions.
emptyPds :: ParsedDefs
stauts :: Lens' ParsedDefs [StautDecl]
purps :: Lens' ParsedDefs [PurpDecl]
cnects :: Lens' ParsedDefs [CnectDecl]
mappers :: Lens' ParsedDefs [MapperDecl]
instance Data.Data.Data TorXakis.Parser.Data.ParsedDefs
instance GHC.Show.Show TorXakis.Parser.Data.ParsedDefs
instance GHC.Classes.Eq TorXakis.Parser.Data.ParsedDefs
instance Data.Data.Data TorXakis.Parser.Data.CodecItem
instance GHC.Show.Show TorXakis.Parser.Data.CodecItem
instance GHC.Classes.Eq TorXakis.Parser.Data.CodecItem
instance Data.Data.Data TorXakis.Parser.Data.CodecType
instance GHC.Show.Show TorXakis.Parser.Data.CodecType
instance GHC.Classes.Eq TorXakis.Parser.Data.CodecType
instance Data.Data.Data TorXakis.Parser.Data.CnectItem
instance GHC.Show.Show TorXakis.Parser.Data.CnectItem
instance GHC.Classes.Eq TorXakis.Parser.Data.CnectItem
instance Data.Data.Data TorXakis.Parser.Data.CnectItemType
instance GHC.Show.Show TorXakis.Parser.Data.CnectItemType
instance GHC.Classes.Ord TorXakis.Parser.Data.CnectItemType
instance GHC.Classes.Eq TorXakis.Parser.Data.CnectItemType
instance Data.Data.Data TorXakis.Parser.Data.CnectType
instance GHC.Show.Show TorXakis.Parser.Data.CnectType
instance GHC.Classes.Eq TorXakis.Parser.Data.CnectType
instance Data.Data.Data TorXakis.Parser.Data.PurpComps
instance GHC.Show.Show TorXakis.Parser.Data.PurpComps
instance GHC.Classes.Eq TorXakis.Parser.Data.PurpComps
instance Data.Data.Data TorXakis.Parser.Data.StautComps
instance GHC.Classes.Ord TorXakis.Parser.Data.StautComps
instance GHC.Show.Show TorXakis.Parser.Data.StautComps
instance GHC.Classes.Eq TorXakis.Parser.Data.StautComps
instance Data.Data.Data TorXakis.Parser.Data.StautItem
instance GHC.Classes.Ord TorXakis.Parser.Data.StautItem
instance GHC.Show.Show TorXakis.Parser.Data.StautItem
instance GHC.Classes.Eq TorXakis.Parser.Data.StautItem
instance Data.Data.Data TorXakis.Parser.Data.Transition
instance GHC.Classes.Ord TorXakis.Parser.Data.Transition
instance GHC.Show.Show TorXakis.Parser.Data.Transition
instance GHC.Classes.Eq TorXakis.Parser.Data.Transition
instance Data.Data.Data TorXakis.Parser.Data.InitStateDecl
instance GHC.Show.Show TorXakis.Parser.Data.InitStateDecl
instance GHC.Classes.Ord TorXakis.Parser.Data.InitStateDecl
instance GHC.Classes.Eq TorXakis.Parser.Data.InitStateDecl
instance Data.Data.Data TorXakis.Parser.Data.StUpdate
instance GHC.Classes.Ord TorXakis.Parser.Data.StUpdate
instance GHC.Show.Show TorXakis.Parser.Data.StUpdate
instance GHC.Classes.Eq TorXakis.Parser.Data.StUpdate
instance Data.Data.Data TorXakis.Parser.Data.ProcComps
instance GHC.Classes.Ord TorXakis.Parser.Data.ProcComps
instance GHC.Show.Show TorXakis.Parser.Data.ProcComps
instance GHC.Classes.Eq TorXakis.Parser.Data.ProcComps
instance Data.Data.Data TorXakis.Parser.Data.ExitSortDecl
instance GHC.Classes.Ord TorXakis.Parser.Data.ExitSortDecl
instance GHC.Show.Show TorXakis.Parser.Data.ExitSortDecl
instance GHC.Classes.Eq TorXakis.Parser.Data.ExitSortDecl
instance Data.Data.Data TorXakis.Parser.Data.ModelComps
instance GHC.Show.Show TorXakis.Parser.Data.ModelComps
instance GHC.Classes.Ord TorXakis.Parser.Data.ModelComps
instance GHC.Classes.Eq TorXakis.Parser.Data.ModelComps
instance Data.Data.Data TorXakis.Parser.Data.BExpDecl
instance GHC.Show.Show TorXakis.Parser.Data.BExpDecl
instance GHC.Classes.Ord TorXakis.Parser.Data.BExpDecl
instance GHC.Classes.Eq TorXakis.Parser.Data.BExpDecl
instance Data.Data.Data TorXakis.Parser.Data.ActOfferDecl
instance GHC.Show.Show TorXakis.Parser.Data.ActOfferDecl
instance GHC.Classes.Ord TorXakis.Parser.Data.ActOfferDecl
instance GHC.Classes.Eq TorXakis.Parser.Data.ActOfferDecl
instance Data.Data.Data TorXakis.Parser.Data.OfferDecl
instance GHC.Show.Show TorXakis.Parser.Data.OfferDecl
instance GHC.Classes.Ord TorXakis.Parser.Data.OfferDecl
instance GHC.Classes.Eq TorXakis.Parser.Data.OfferDecl
instance Data.Data.Data TorXakis.Parser.Data.ChanOfferDecl
instance GHC.Show.Show TorXakis.Parser.Data.ChanOfferDecl
instance GHC.Classes.Ord TorXakis.Parser.Data.ChanOfferDecl
instance GHC.Classes.Eq TorXakis.Parser.Data.ChanOfferDecl
instance Data.Data.Data TorXakis.Parser.Data.SyncOn
instance GHC.Show.Show TorXakis.Parser.Data.SyncOn
instance GHC.Classes.Ord TorXakis.Parser.Data.SyncOn
instance GHC.Classes.Eq TorXakis.Parser.Data.SyncOn
instance Data.Data.Data TorXakis.Parser.Data.FuncComps
instance GHC.Classes.Ord TorXakis.Parser.Data.FuncComps
instance GHC.Show.Show TorXakis.Parser.Data.FuncComps
instance GHC.Classes.Eq TorXakis.Parser.Data.FuncComps
instance Data.Data.Data TorXakis.Parser.Data.ExpChild
instance GHC.Show.Show TorXakis.Parser.Data.ExpChild
instance GHC.Classes.Ord TorXakis.Parser.Data.ExpChild
instance GHC.Classes.Eq TorXakis.Parser.Data.ExpChild
instance Data.Data.Data TorXakis.Parser.Data.ParLetVarDecl
instance GHC.Show.Show TorXakis.Parser.Data.ParLetVarDecl
instance GHC.Classes.Ord TorXakis.Parser.Data.ParLetVarDecl
instance GHC.Classes.Eq TorXakis.Parser.Data.ParLetVarDecl
instance Data.Data.Data TorXakis.Parser.Data.Const
instance GHC.Classes.Ord TorXakis.Parser.Data.Const
instance GHC.Show.Show TorXakis.Parser.Data.Const
instance GHC.Classes.Eq TorXakis.Parser.Data.Const
instance Data.Data.Data TorXakis.Parser.Data.ActPrefE
instance GHC.Show.Show TorXakis.Parser.Data.ActPrefE
instance GHC.Classes.Ord TorXakis.Parser.Data.ActPrefE
instance GHC.Classes.Eq TorXakis.Parser.Data.ActPrefE
instance Data.Data.Data TorXakis.Parser.Data.AcceptE
instance GHC.Show.Show TorXakis.Parser.Data.AcceptE
instance GHC.Classes.Ord TorXakis.Parser.Data.AcceptE
instance GHC.Classes.Eq TorXakis.Parser.Data.AcceptE
instance Data.Data.Data TorXakis.Parser.Data.HideE
instance GHC.Show.Show TorXakis.Parser.Data.HideE
instance GHC.Classes.Ord TorXakis.Parser.Data.HideE
instance GHC.Classes.Eq TorXakis.Parser.Data.HideE
instance Data.Data.Data TorXakis.Parser.Data.ChoiceE
instance GHC.Show.Show TorXakis.Parser.Data.ChoiceE
instance GHC.Classes.Ord TorXakis.Parser.Data.ChoiceE
instance GHC.Classes.Eq TorXakis.Parser.Data.ChoiceE
instance Data.Data.Data TorXakis.Parser.Data.InterruptE
instance GHC.Show.Show TorXakis.Parser.Data.InterruptE
instance GHC.Classes.Ord TorXakis.Parser.Data.InterruptE
instance GHC.Classes.Eq TorXakis.Parser.Data.InterruptE
instance Data.Data.Data TorXakis.Parser.Data.DisableE
instance GHC.Show.Show TorXakis.Parser.Data.DisableE
instance GHC.Classes.Ord TorXakis.Parser.Data.DisableE
instance GHC.Classes.Eq TorXakis.Parser.Data.DisableE
instance Data.Data.Data TorXakis.Parser.Data.EnableE
instance GHC.Show.Show TorXakis.Parser.Data.EnableE
instance GHC.Classes.Ord TorXakis.Parser.Data.EnableE
instance GHC.Classes.Eq TorXakis.Parser.Data.EnableE
instance Data.Data.Data TorXakis.Parser.Data.ParOpE
instance GHC.Show.Show TorXakis.Parser.Data.ParOpE
instance GHC.Classes.Ord TorXakis.Parser.Data.ParOpE
instance GHC.Classes.Eq TorXakis.Parser.Data.ParOpE
instance Data.Data.Data TorXakis.Parser.Data.MapperDeclE
instance GHC.Show.Show TorXakis.Parser.Data.MapperDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.MapperDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.MapperDeclE
instance Data.Data.Data TorXakis.Parser.Data.CnectDeclE
instance GHC.Show.Show TorXakis.Parser.Data.CnectDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.CnectDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.CnectDeclE
instance Data.Data.Data TorXakis.Parser.Data.GoalDeclE
instance GHC.Show.Show TorXakis.Parser.Data.GoalDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.GoalDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.GoalDeclE
instance Data.Data.Data TorXakis.Parser.Data.PurpDeclE
instance GHC.Show.Show TorXakis.Parser.Data.PurpDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.PurpDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.PurpDeclE
instance Data.Data.Data TorXakis.Parser.Data.StateRefE
instance GHC.Show.Show TorXakis.Parser.Data.StateRefE
instance GHC.Classes.Ord TorXakis.Parser.Data.StateRefE
instance GHC.Classes.Eq TorXakis.Parser.Data.StateRefE
instance Data.Data.Data TorXakis.Parser.Data.StateDeclE
instance GHC.Show.Show TorXakis.Parser.Data.StateDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.StateDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.StateDeclE
instance Data.Data.Data TorXakis.Parser.Data.StautDeclE
instance GHC.Show.Show TorXakis.Parser.Data.StautDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.StautDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.StautDeclE
instance Data.Data.Data TorXakis.Parser.Data.ProcRefE
instance GHC.Show.Show TorXakis.Parser.Data.ProcRefE
instance GHC.Classes.Ord TorXakis.Parser.Data.ProcRefE
instance GHC.Classes.Eq TorXakis.Parser.Data.ProcRefE
instance Data.Data.Data TorXakis.Parser.Data.ProcDeclE
instance GHC.Show.Show TorXakis.Parser.Data.ProcDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.ProcDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.ProcDeclE
instance Data.Data.Data TorXakis.Parser.Data.ModelDeclE
instance GHC.Show.Show TorXakis.Parser.Data.ModelDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.ModelDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.ModelDeclE
instance Data.Data.Data TorXakis.Parser.Data.ChanRefE
instance GHC.Show.Show TorXakis.Parser.Data.ChanRefE
instance GHC.Classes.Ord TorXakis.Parser.Data.ChanRefE
instance GHC.Classes.Eq TorXakis.Parser.Data.ChanRefE
instance Data.Data.Data TorXakis.Parser.Data.ChanDeclE
instance GHC.Show.Show TorXakis.Parser.Data.ChanDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.ChanDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.ChanDeclE
instance Data.Data.Data TorXakis.Parser.Data.ConstLitE
instance GHC.Show.Show TorXakis.Parser.Data.ConstLitE
instance GHC.Classes.Ord TorXakis.Parser.Data.ConstLitE
instance GHC.Classes.Eq TorXakis.Parser.Data.ConstLitE
instance Data.Data.Data TorXakis.Parser.Data.VarRefE
instance GHC.Show.Show TorXakis.Parser.Data.VarRefE
instance GHC.Classes.Ord TorXakis.Parser.Data.VarRefE
instance GHC.Classes.Eq TorXakis.Parser.Data.VarRefE
instance Data.Data.Data TorXakis.Parser.Data.VarDeclE
instance GHC.Show.Show TorXakis.Parser.Data.VarDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.VarDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.VarDeclE
instance Data.Data.Data TorXakis.Parser.Data.ExpDeclE
instance GHC.Show.Show TorXakis.Parser.Data.ExpDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.ExpDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.ExpDeclE
instance Data.Data.Data TorXakis.Parser.Data.FuncDeclE
instance GHC.Show.Show TorXakis.Parser.Data.FuncDeclE
instance GHC.Classes.Ord TorXakis.Parser.Data.FuncDeclE
instance GHC.Classes.Eq TorXakis.Parser.Data.FuncDeclE
instance Data.Data.Data TorXakis.Parser.Data.SortRefE
instance GHC.Show.Show TorXakis.Parser.Data.SortRefE
instance GHC.Classes.Ord TorXakis.Parser.Data.SortRefE
instance GHC.Classes.Eq TorXakis.Parser.Data.SortRefE
instance Data.Data.Data TorXakis.Parser.Data.FieldE
instance GHC.Show.Show TorXakis.Parser.Data.FieldE
instance GHC.Classes.Ord TorXakis.Parser.Data.FieldE
instance GHC.Classes.Eq TorXakis.Parser.Data.FieldE
instance Data.Data.Data TorXakis.Parser.Data.CstrE
instance GHC.Show.Show TorXakis.Parser.Data.CstrE
instance GHC.Classes.Ord TorXakis.Parser.Data.CstrE
instance GHC.Classes.Eq TorXakis.Parser.Data.CstrE
instance Data.Data.Data TorXakis.Parser.Data.ADTE
instance GHC.Show.Show TorXakis.Parser.Data.ADTE
instance GHC.Classes.Ord TorXakis.Parser.Data.ADTE
instance GHC.Classes.Eq TorXakis.Parser.Data.ADTE
instance (Data.Data.Data c, Data.Data.Data t) => Data.Data.Data (TorXakis.Parser.Data.ParseTree t c)
instance (GHC.Classes.Ord c, GHC.Classes.Ord t) => GHC.Classes.Ord (TorXakis.Parser.Data.ParseTree t c)
instance (GHC.Classes.Eq c, GHC.Classes.Eq t) => GHC.Classes.Eq (TorXakis.Parser.Data.ParseTree t c)
instance (GHC.Show.Show c, GHC.Show.Show t) => GHC.Show.Show (TorXakis.Parser.Data.ParseTree t c)
instance Data.Data.Data t => Data.Data.Data (TorXakis.Parser.Data.Loc t)
instance GHC.Classes.Ord (TorXakis.Parser.Data.Loc t)
instance GHC.Classes.Eq (TorXakis.Parser.Data.Loc t)
instance GHC.Show.Show (TorXakis.Parser.Data.Loc t)
instance Data.Data.Data t => Data.Data.Data (TorXakis.Parser.Data.Name t)
instance GHC.Classes.Ord (TorXakis.Parser.Data.Name t)
instance GHC.Classes.Eq (TorXakis.Parser.Data.Name t)
instance GHC.Show.Show (TorXakis.Parser.Data.Name t)
instance GHC.Show.Show TorXakis.Parser.Data.St
instance GHC.Classes.Eq TorXakis.Parser.Data.St
instance TorXakis.Parser.Data.IsVariable TorXakis.Parser.Data.VarRef
instance TorXakis.Parser.Data.IsVariable TorXakis.Parser.Data.LetVarDecl
instance GHC.Exts.IsList TorXakis.Parser.Data.ParLetVarDecl
instance TorXakis.Parser.Data.IsVariable TorXakis.Parser.Data.VarDecl
instance TorXakis.Parser.Data.IsVariable TorXakis.Parser.Data.IVarDecl
instance TorXakis.Parser.Data.HasLoc (TorXakis.Parser.Data.ParseTree t c) t
instance (Data.Data.Data t, Data.Data.Data c) => Control.Lens.Plated.Plated (TorXakis.Parser.Data.ParseTree t c)
instance TorXakis.Compiler.Error.HasErrorLoc (TorXakis.Parser.Data.ParseTree t c)
instance Data.Data.Data t => Control.Lens.Plated.Plated (TorXakis.Parser.Data.Loc t)
instance TorXakis.Compiler.Error.HasErrorLoc (TorXakis.Parser.Data.Loc t)


-- | Common types and functionality for the <tt>TorXakis</tt> parser.
module TorXakis.Parser.Common
type TxsParser = ParsecT ParserInput St Identity

-- | Parse given symbol, discarding its result.
txsSymbol :: String -> TxsParser ()

-- | Parser for identifiers, which may start with lower or upper case
--   letters.
identifier :: TxsParser Text

-- | Make a new location while parsing.
mkLoc :: TxsParser (Loc t)

-- | Parser for lower-case identifiers.
lcIdentifier :: TxsParser Text

-- | Parser for lexemes.
txsLexeme :: TxsParser a -> TxsParser a

-- | Parser for upper-case identifiers.
ucIdentifier :: String -> TxsParser Text

-- | Parser for integer.
txsIntP :: TxsParser Integer

-- | Parser for strings.
txsStringP :: TxsParser Text

-- | Parser that ignores white-spaces.
txsWhitespace :: TxsParser ()

-- | Parse expressions of the form "IN exp NI", where <tt>p</tt> is the
--   expressions parser.
inP :: TxsParser a -> TxsParser a

-- | Like <tt>identifier</tt>, but try.
tryIdentifier :: TxsParser Text

-- | Parser for declarations of the form:
--   
--   <pre>
--   XDEF n ::= p ENDEF
--   </pre>
--   
--   Where n is the name of the definition, p is the parser that parses the
--   body of the declaration, and <tt>XDEF</tt> is the declaration name
--   (e.g. <tt>MODELDEF</tt>).
declP :: String -> (Text -> Loc l -> TxsParser a) -> TxsParser a

-- | Parser for declarations with parameters of the form: <tt> XDEF n
--   params ::= body ENDEF </tt>
--   
--   Where <tt>n</tt> is the name of the definition, <tt>params</tt> are
--   the parameters taken by the declaration, <tt>body</tt> is the body of
--   the declaration, and <tt>XDEF</tt> is the declaration name (e.g.
--   <tt>PROCDEF</tt>). The boolean parameter of this function indicates
--   whether '<a>ENDDEF</a>' is required.
declWithParamsP :: String -> TxsParser params -> (params -> Text -> Loc l -> TxsParser a) -> Bool -> TxsParser a


-- | Parser for channel references.
module TorXakis.Parser.ChanRef

-- | Parser for synchronizing channel declarations.
chansSyncDecl :: TxsParser (Maybe [Set ChanRef])

-- | Parser for output channel declarations.
chansOutDecl :: TxsParser [ChanRef]

-- | Parser for input channel declarations.
chansInDecl :: TxsParser [ChanRef]

-- | Parser for channel references.
channelRefP :: TxsParser ChanRef


-- | Compilation functions related to <tt>TorXakis</tt> variable id's.
module TorXakis.Compiler.ValExpr.VarId

-- | Create variable id's from the given expression.
mkVarIds :: (DeclaresVariables e, MapsTo (Loc VarDeclE) SortId mm) => mm -> e -> CompilerM [(Loc VarDeclE, VarId)]

-- | Generate a variable id from a variable declaration.
varIdFromVarDecl :: (MapsTo (Loc VarDeclE) SortId mm, IsVariable v, HasLoc v VarDeclE) => mm -> v -> CompilerM (Loc VarDeclE, VarId)

-- | Expressions that declare variables.
class DeclaresVariables e

-- | Create variable id's from the given expression.
mkVarIds :: (DeclaresVariables e, MapsTo (Loc VarDeclE) SortId mm) => mm -> e -> CompilerM [(Loc VarDeclE, VarId)]

-- | Generate the variable ids that are defined in a list of function
--   declarations.
generateVarIds :: (MapsTo (Loc VarDeclE) SortId mm) => mm -> [FuncDecl] -> CompilerM (Map (Loc VarDeclE) VarId)
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.VarDecl
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.BExpDecl
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.ParLetVarDecl
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.ActOfferDecl
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables e => TorXakis.Compiler.ValExpr.VarId.DeclaresVariables (GHC.Base.Maybe e)
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables e => TorXakis.Compiler.ValExpr.VarId.DeclaresVariables [e]
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.OfferDecl
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.ChanOfferDecl
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.ExpDecl
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.LetVarDecl
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.Transition
instance TorXakis.Compiler.ValExpr.VarId.DeclaresVariables TorXakis.Parser.Data.TestGoalDecl


-- | Compilation to <tt>TorXakis</tt> <tt>Const</tt>'s.
module TorXakis.Compiler.ValExpr.ConstDefs

-- | Transform a constant declaration into a <tt>TorXakis</tt>
--   <tt>Const</tt>.
constToConstDef :: SortId -> Const -> Const


-- | Compiler specific maps and operations on them.
module TorXakis.Compiler.Maps

-- | Infix version of lookup, for those keys that have an error location.
(.@) :: (HasErrorLoc k, MapsTo k v mm, Ord k, Show k, Typeable k, Typeable v) => mm -> k -> Either Error v

-- | Lookup the given key, and use the given location for error reporting.
(.@!!) :: (HasErrorLoc l, MapsTo k v mm, Ord k, Show k, Typeable k, Typeable v) => mm -> (k, l) -> CompilerM v

-- | Monadic version of <tt>.@</tt>.
(.@@) :: (HasErrorLoc k, MapsTo k v mm, Ord k, Show k, Typeable k, Typeable v) => mm -> k -> CompilerM v

-- | Set the error location (monadic version).
(<!!>) :: HasErrorLoc l => CompilerM a -> l -> CompilerM a

-- | Find the nullary function declaration that corresponds to a variable
--   reference. A nullary function is a funciton without arguments.
findFuncDecl :: MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm => mm -> Loc VarRefE -> Either Error [Loc FuncDeclE]

-- | Select the function definitions that matches the given arguments and
--   return types.
determineF :: MapsTo (Loc FuncDeclE) Signature mm => mm -> [Loc FuncDeclE] -> [SortId] -> Maybe SortId -> [Loc FuncDeclE]

-- | Get the function definition if the given list is a singleton, return
--   an error otherwise.
getUniqueElement :: Show a => [a] -> Either Error a

-- | Lookup the <tt>ChanId</tt> associated to the given location.
lookupChId :: (MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm) => mm -> Loc ChanRefE -> CompilerM ChanId

-- | Given a list of channel references and a composite map, get the
--   <tt>ChanId</tt>'s associated to those references.
chRefsToIds :: (MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm) => mm -> [ChanRef] -> CompilerM [ChanId]

-- | Lookup the <tt>SortId</tt> associated to the given name, using the
--   location for error reporting.
findSortId :: MapsTo Text SortId mm => mm -> (Text, Loc t) -> Either Error SortId

-- | Find all the return <tt>SortId</tt>'s of the given function
--   declarations.
findFuncSortIds :: MapsTo (Loc FuncDeclE) Signature mm => mm -> [Loc FuncDeclE] -> Either Error [SortId]

-- | Monadic version of <tt>findSortIdM</tt>
findSortIdM :: MapsTo Text SortId mm => mm -> (Text, Loc t) -> CompilerM SortId

-- | Determine the signature and the handler based on the sort arguments
--   and the expected return type (if any).
determineSH :: [(Signature, Handler VarId)] -> [SortId] -> Maybe SortId -> Either Error (Signature, Handler VarId)

-- | Find the right element (if any) that corresponds to the given
--   location.
findRight :: forall a b. (Typeable a, Typeable b) => Map (Loc VarRefE) (Either a b) -> Loc VarRefE -> Either Error b

-- | Channels referred in the model
usedChIdMap :: (MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm) => mm -> Map (Loc ChanRefE) ChanId

-- | Monadic version of <tt>findVarId</tt>.
findVarIdM :: (MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc VarDeclE) VarId mm) => mm -> Loc VarRefE -> CompilerM VarId

-- | Extract the names of the implicit function declarations in the map.
idefsNames :: MapsTo (Loc FuncDeclE) FuncId mm => mm -> [Text]

-- | Get the list of channel ids used in an expression (model, purpose,
--   etc).
usedChIds :: (MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm) => mm -> [Set ChanId]

-- | Join two maps <tt>m0</tt> and <tt>m1</tt>. A pair '(k, w)' is in the
--   resulting map if and only if there is a key <tt>v</tt> such that '(k,
--   v)' is in <tt>m0</tt> and '(v, w)' is in <tt>m1</tt>.
join :: (Ord k, Ord v) => Map k v -> Map v w -> Map k w

-- | Drop the handler from the map.
dropHandler :: Map (Loc FuncDeclE) (Signature, Handler VarId) -> Map (Loc FuncDeclE) Signature


-- | Compilation functions related to to <tt>SortId</tt> values.
module TorXakis.Compiler.ValExpr.SortId

-- | Find the <tt>SortId</tt> of a variable declaration.
sortIdOfVarDecl :: MapsTo Text SortId mm => mm -> VarDecl -> Either Error SortId

-- | Monadic version of <tt>sortIdOfVarDecl</tt>.
sortIdOfVarDeclM :: MapsTo Text SortId mm => mm -> VarDecl -> CompilerM SortId

-- | Check that the two sorts match.
checkSortIds :: SortId -> SortId -> Either Error ()

-- | <tt>SortId</tt> of a constant.
sortIdConst :: Const -> Maybe SortId
sortIds :: (MapsTo Text SortId mm) => mm -> [OfSort] -> CompilerM [SortId]
exitSortIds :: ExitSort -> [SortId]
offerSid :: (MapsTo Text SortId mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc FuncDeclE) Signature mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm) => mm -> ChanOfferDecl -> CompilerM SortId

-- | Obtain the exit sorts for an expression.
exitSort :: (HasExitSorts e, MapsTo Text SortId mm, MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, MapsTo ProcId () mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc FuncDeclE) Signature mm) => mm -> e -> CompilerM ExitSort
inferVarTypes :: HasTypedVars mm e => mm -> e -> CompilerM [(Loc VarDeclE, SortId)]

-- | An expression has typed-variables if a map can be found from the
--   location of variable declarations, to their associated
--   <tt>SortId</tt>.
class HasTypedVars mm e
inferVarTypes :: HasTypedVars mm e => mm -> e -> CompilerM [(Loc VarDeclE, SortId)]

-- | Infer the types in a list of function declarations.
inferTypes :: (MapsTo Text SortId mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc FuncDeclE) Signature mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm) => mm -> [FuncDecl] -> CompilerM (Map (Loc VarDeclE) SortId)

-- | Infer the type of an expression. Due to function overloading an
--   expression could have multiple types, e.g.:
--   
--   <pre>
--   fromString("33")
--   </pre>
--   
--   Could be a TorXakis <a>Int</a>, <a>String</a>, <a>Bool</a>, or even an
--   <tt>ADT</tt>.
inferExpTypes :: (MapsTo Text SortId mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc FuncDeclE) Signature mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm) => mm -> ExpDecl -> Either Error [SortId]

-- | Construct a list of sort ID's from a list of ADT declarations.
--   
--   The ID of the ADT will coincide with the ID of the SortId.
compileToSortId :: [ADTDecl] -> CompilerM (Map Text SortId)
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId mm, TorXakis.Compiler.MapsTo.MapsTo ProcId.ProcId () mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.BExpDecl
instance TorXakis.Compiler.ValExpr.SortId.HasExitSorts TorXakis.Parser.Data.BExpDecl
instance TorXakis.Compiler.ValExpr.SortId.HasExitSorts TorXakis.Parser.Data.ActOfferDecl
instance TorXakis.Compiler.ValExpr.SortId.HasExitSorts e => TorXakis.Compiler.ValExpr.SortId.HasExitSorts [e]
instance TorXakis.Compiler.ValExpr.SortId.HasExitSorts TorXakis.Parser.Data.OfferDecl
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.VarDecl
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm, TorXakis.Compiler.MapsTo.MapsTo ProcId.ProcId () mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.ActOfferDecl
instance TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm e => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm (GHC.Base.Maybe e)
instance TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm e => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm [e]
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.ExpDecl
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.LetVarDecl
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.ParLetVarDecl
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm, TorXakis.Compiler.MapsTo.MapsTo ProcId.ProcId () mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.OfferDecl
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm, TorXakis.Compiler.MapsTo.MapsTo ProcId.ProcId () mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.ChanOfferDecl
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm, TorXakis.Compiler.MapsTo.MapsTo ProcId.ProcId () mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.Transition
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE) FuncTable.Signature mm, TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarRefE) (Data.Either.Either (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) [TorXakis.Parser.Data.Loc TorXakis.Parser.Data.FuncDeclE]) mm, TorXakis.Compiler.MapsTo.MapsTo ProcId.ProcId () mm) => TorXakis.Compiler.ValExpr.SortId.HasTypedVars mm TorXakis.Parser.Data.TestGoalDecl


-- | Compilation functions related to <tt>TorXakis</tt> function id's.
module TorXakis.Compiler.ValExpr.FuncId

-- | Define the accessor function for a constructor, using the given field.
cstrToAccFuncId :: MapsTo Text SortId mm => mm -> CstrId -> FieldDecl -> CompilerM FuncId

-- | Make a function id from the given constructor id.
cstrToIsCstrFuncId :: CstrId -> CompilerM FuncId

-- | Make a <a>FuncId</a> for a string to sort function.
sortFromStringFuncId :: SortId -> CompilerM FuncId

-- | Make a <a>FuncId</a> for a sort to string function.
sortToStringFuncId :: SortId -> CompilerM FuncId

-- | Create the function id's that the ADT implicitly defines.
adtsToFuncIds :: (MapsTo Text SortId mm) => mm -> [ADTDecl] -> CompilerM [(Loc FuncDeclE, FuncId)]

-- | Return the function id as a signature.
funcIdAsSignature :: FuncId -> Signature

-- | Compile a list of function declarations to a list of pairs consisting
--   of the function location and its id.
funcDeclsToFuncIds :: MapsTo Text SortId mm => mm -> [FuncDecl] -> CompilerM [(Loc FuncDeclE, FuncId)]

-- | Generate the function id's that correspond to the functions in the
--   standard function table (<tt>stdFuncTable</tt>)
getStdFuncIds :: CompilerM [(Loc FuncDeclE, FuncId)]


-- | Compilation functions related to <tt>TorXakis</tt> constructor
--   definitions.
module TorXakis.Compiler.ValExpr.CstrDef

-- | Compile a list of ADT declarations into a map from constructor id's to
--   their definitions.
compileToCstrDefs :: (MapsTo Text SortId mm, MapsTo (Loc CstrE) CstrId mm) => mm -> [ADTDecl] -> CompilerM (Map CstrId CstrDef)


-- | Compilation functions related to expression declarations.
module TorXakis.Compiler.ValExpr.ExpDecl

-- | Expressions that have variable references.
class HasVarReferences e

-- | Map variable references to the entities they refer to.
--   
--   NOTE: property to check:
--   
--   the number of 'Loc FuncDeclE' entities in the function declaration
--   should equal the length of the list returned by this function.
--   
--   This ensures that the mapping returned is complete.
--   
--   This class could be replaced by <tt>DefinesAMap</tt> which already
--   includes such an invariant check.
mapRefToDecls :: (HasVarReferences e, MapsTo Text [Loc FuncDeclE] mm, MapsTo Text (Loc VarDeclE) mm) => mm -> e -> CompilerM [(Loc VarRefE, Either (Loc VarDeclE) [Loc FuncDeclE])]

-- | Map variable references to the entities they refer to.
--   
--   NOTE: property to check:
--   
--   the number of 'Loc FuncDeclE' entities in the function declaration
--   should equal the length of the list returned by this function.
--   
--   This ensures that the mapping returned is complete.
--   
--   This class could be replaced by <tt>DefinesAMap</tt> which already
--   includes such an invariant check.
mapRefToDecls :: (HasVarReferences e, MapsTo Text [Loc FuncDeclE] mm, MapsTo Text (Loc VarDeclE) mm) => mm -> e -> CompilerM [(Loc VarRefE, Either (Loc VarDeclE) [Loc FuncDeclE])]
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences e => TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences [e]
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.ProcDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.BExpDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.ActOfferDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences e => TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences (GHC.Base.Maybe e)
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.ExpDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.ParLetVarDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.OfferDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.ChanOfferDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.FuncDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.ModelDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.MapperDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.StautDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.StautItem
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.StUpdate
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.VarRef
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.Transition
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.PurpDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.TestGoalDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.CnectDecl
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.CodecItem
instance TorXakis.Compiler.ValExpr.ExpDecl.HasVarReferences TorXakis.Parser.Data.VarDecl


-- | Compilation functions related to <tt>TorXakis</tt> constructor id's.
module TorXakis.Compiler.ValExpr.CstrId

-- | Compile a list of ADT declarations into a map from the location of the
--   constructor declaration, to their corresponding constructor id's.
compileToCstrId :: (MapsTo Text SortId mm) => mm -> [ADTDecl] -> CompilerM (Map (Loc CstrE) CstrId)


-- | Functions to manipulate maps of variable references.
module TorXakis.Compiler.Maps.VarRef

-- | Get the variable id that corresponds to the given reference.
varIdForRef :: forall a. Typeable a => Map (Loc VarRefE) (Either VarId a) -> Loc VarRefE -> Either Error VarId

-- | Given an expression, construct a map from variable references to the
--   concrete TorXakis entities they refer to.
varDefsFromExp :: (MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc VarDeclE) VarId mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, Data e) => mm -> e -> Either Error (Map (Loc VarRefE) (Either VarId [(Signature, Handler VarId)]))


-- | Compilation functions related to <tt>TorXakis</tt> value expressions.
module TorXakis.Compiler.ValExpr.ValExpr

-- | Compile an expression declaration into a value expression, given a map
--   of variable references to the entities they refer, and the expected
--   sort id.
expDeclToValExpr :: Map (Loc VarRefE) (Either VarId [(Signature, Handler VarId)]) -> SortId -> ExpDecl -> Either Error (ValExpr VarId)

-- | Compile a parallel let-variable declaration into a map of variable
--   id's to the expressions they are associated with.
parValDeclToMap :: Map (Loc VarRefE) (Either VarId [(Signature, Handler VarId)]) -> ParLetVarDecl -> Either Error (Map VarId (ValExpr VarId))


-- | Compilation functions related to <tt>TorXakis</tt> function
--   definitions.
module TorXakis.Compiler.ValExpr.FuncDef

-- | Information about a function definition.
data FuncDefInfo
funcHandler :: FuncDefInfo -> Handler VarId

-- | Make a function <tt>Signature</tt>-<tt>Handler</tt> pair from a
--   function <tt>FuncDecl</tt>.
funcDeclToSH :: Map (Loc FuncDeclE) FuncId -> FuncDecl -> CompilerM (Loc FuncDeclE, (Signature, Handler VarId))

-- | Compile function declarations to function definitions.
funcDeclsToFuncDefs :: (MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc VarDeclE) VarId mm, MapsTo (Loc FuncDeclE) FuncId mm, In (FuncId, FuncDefInfo) (Contents mm) ~  'False, In (Loc FuncDeclE, (Signature, Handler VarId)) (Contents mm) ~  'False) => mm -> Map (Loc FuncDeclE) (Signature, Handler VarId) -> [FuncDecl] -> CompilerM (Map FuncId FuncDefInfo)

-- | Return the inner signal handler map of the composite map.
innerSigHandlerMap :: (MapsTo (Loc FuncDeclE) FuncId mm, MapsTo FuncId FuncDefInfo mm) => mm -> Map (Loc FuncDeclE) (Signature, Handler VarId)
funcDef :: FuncDefInfo -> FuncDef VarId


-- | Expressions that define a map.
module TorXakis.Compiler.Maps.DefinesAMap

-- | Abstract syntax tree types that define a map.
--   
--   'DefinesAMap k v e mm' models the fact that an AST <tt>e</tt> defines
--   a map from <tt>k</tt> to <tt>v</tt>, provided a map <tt>mm</tt> is
--   available.
class (Show k, Ord k, Eq k) => DefinesAMap k v e mm

-- | Get the <tt>k</tt> <tt>v</tt> pairs defined by the ast <tt>e</tt>.
getKVs :: DefinesAMap k v e mm => mm -> e -> CompilerM [(k, v)]

-- | Get the dictionary of <tt>k</tt> <tt>v</tt> pairs defined by the ast
--   <tt>e</tt>.
getMap :: (DefinesAMap k v e mm, Ord k) => mm -> e -> CompilerM (Map k v)

-- | Get the list of keys defined in <tt>e</tt>. This is used for invariant
--   checking.
getKs :: DefinesAMap k v e mm => e -> [k]

-- | Get the list of keys defined in <tt>e</tt>. This is used for invariant
--   checking.
getKs :: (DefinesAMap k v e mm, Data e, Typeable k) => e -> [k]

-- | Get the <tt>k</tt> <tt>v</tt> pairs defined by the ast <tt>e</tt>,
--   without checking for the invariant. Unchecked version of
--   <a>getKVs</a>.
uGetKVs :: DefinesAMap k v e mm => mm -> e -> CompilerM [(k, v)]

-- | Get the <tt>k</tt> <tt>v</tt> pairs defined by the ast <tt>e</tt>.
getKVs :: DefinesAMap k v e mm => mm -> e -> CompilerM [(k, v)]

-- | Get the list of keys defined in <tt>e</tt>. This is used for invariant
--   checking.
getKs :: DefinesAMap k v e mm => e -> [k]

-- | Get the dictionary of <tt>k</tt> <tt>v</tt> pairs defined by the ast
--   <tt>e</tt>.
getMap :: (DefinesAMap k v e mm, Ord k) => mm -> e -> CompilerM (Map k v)

-- | Get the <tt>k</tt> <tt>v</tt> pairs defined by the ast <tt>e</tt>,
--   without checking for the invariant. Unchecked version of
--   <a>getKVs</a>.
uGetKVs :: DefinesAMap k v e mm => mm -> e -> CompilerM [(k, v)]

-- | Predefined channels declarations.
predefChDecls :: Map Text (Loc ChanDeclE)
instance (Data.Data.Data e, Data.Typeable.Internal.Typeable k, TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap k v e mm) => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap k v [e] mm
instance (Data.Data.Data e, Data.Typeable.Internal.Typeable k, TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap k v e mm) => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap k v (GHC.Base.Maybe e) mm
instance (Data.Data.Data e, Data.Typeable.Internal.Typeable k, GHC.Classes.Ord e, TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap k v e mm) => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap k v (Data.Set.Internal.Set e) mm
instance TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.ChanDecl ()
instance TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.ParsedDefs ()
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.ModelDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.PurpDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.MapperDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.CnectDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.CnectItem mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.CodecItem mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.TestGoalDecl mm
instance TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.ProcDecl ()
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.BExpDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.ActOfferDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.OfferDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.ChanRef mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.SyncOn mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.ParsedDefs mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.ChanDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.ProcDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.StautDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.ModelDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.MapperDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.PurpDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.TestGoalDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.BExpDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) ChanId.ChanId TorXakis.Parser.Data.ExitSortDecl mm
instance TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.ExpDecl mm
instance TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.ParLetVarDecl mm
instance TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.VarDecl mm


-- | Compilation functions related to <tt>TorXakis</tt> function tables.
module TorXakis.Compiler.Defs.FuncTable

-- | Make a function table from a list of ADT's declarations.
adtsToFuncTable :: (MapsTo Text SortId mm, MapsTo (Loc CstrE) CstrId mm) => mm -> [ADTDecl] -> CompilerM (FuncTable VarId)

-- | Create a function table from a list of function declarations.
funcDeclsToFuncTable :: (MapsTo Text SortId mm, MapsTo (Loc FuncDeclE) FuncId mm, MapsTo FuncId FuncDefInfo mm) => mm -> [FuncDecl] -> CompilerM (FuncTable VarId)

-- | Make a map from location of function declarations to their signature
--   and handlers, using the given map and function table.
fLocToSignatureHandlers :: Map (Loc FuncDeclE) FuncId -> FuncTable VarId -> CompilerM (Map (Loc FuncDeclE) (Signature, Handler VarId))


-- | Compilation functions related to <tt>TorXakis</tt> signatures.
module TorXakis.Compiler.Defs.Sigs

-- | Compile ADT declarations into <tt>TorXakis</tt> signatures.
adtDeclsToSigs :: (MapsTo Text SortId mm, MapsTo (Loc CstrE) CstrId mm) => mm -> [ADTDecl] -> CompilerM (Sigs VarId)

-- | Compile function declarations <tt>TorXakis</tt> signatures.
funDeclsToSigs :: (MapsTo Text SortId mm, MapsTo (Loc FuncDeclE) FuncId mm, MapsTo FuncId FuncDefInfo mm) => mm -> [FuncDecl] -> CompilerM (Sigs VarId)

-- | Compile a map from <a>Text</a> to <tt>SortId</tt> into
--   <tt>TorXakis</tt> signatures.
sortsToSigs :: Map Text SortId -> Sigs VarId


-- | Compilation functions related to <tt>TorXakis</tt> behavior
--   expressions.
module TorXakis.Compiler.Defs.BehExprDefs

-- | Compile a behavior expression declaration into a behavior expression.
toBExpr :: (MapsTo Text SortId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, MapsTo ProcId () mm, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False) => mm -> Map (Loc VarRefE) (Either VarId [(Signature, Handler VarId)]) -> BExpDecl -> CompilerM BExpr

-- | Compile a list offer declarations on a channel into a list of offer
--   declarations.
toOffer :: (MapsTo Text SortId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False) => mm -> Map (Loc VarRefE) (Either VarId [(Signature, Handler VarId)]) -> OfferDecl -> CompilerM Offer

-- | Compile an action offer declaration into an action offer.
toActOffer :: (MapsTo Text SortId mm, MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo (Loc VarDeclE) SortId mm, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False) => mm -> Map (Loc VarRefE) (Either VarId [(Signature, Handler VarId)]) -> ActOfferDecl -> CompilerM ActOffer


-- | Compilation functions related to <tt>TorXakis</tt> model definitions.
module TorXakis.Compiler.Defs.ModelDef

-- | Compile a model declaration into a model definition.
modelDeclToModelDef :: (MapsTo Text SortId mm, MapsTo Text (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo ProcId () mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc VarDeclE) VarId mm, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False, In (Loc ChanRefE, Loc ChanDeclE) (Contents mm) ~  'False) => mm -> ModelDecl -> CompilerM ModelDef

-- | Compile a set of channel references to the set of channel id's they
--   refer to.
chRefsToChIdSet :: (MapsTo (Loc ChanRefE) (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm) => mm -> Set ChanRef -> CompilerM (Set ChanId)


-- | Compilation functions related to <tt>TorXakis</tt> definitions.
module TorXakis.Compiler.Defs.TxsDefs

-- | Compile a list of ADT declarations into <tt>TxsDefs</tt>.
adtsToTxsDefs :: (MapsTo Text SortId mm, MapsTo (Loc CstrE) CstrId mm) => mm -> [ADTDecl] -> CompilerM TxsDefs

-- | Compile a list of connect declarations into a map from connect id's to
--   connect definitions.
cnectDeclsToTxsDefs :: (MapsTo Text SortId mm, MapsTo Text (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc VarDeclE) VarId mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False, In (ProcId, ()) (Contents mm) ~  'False, In (Loc ChanRefE, Loc ChanDeclE) (Contents mm) ~  'False) => mm -> [CnectDecl] -> CompilerM (Map CnectId CnectDef)

-- | Compile a list of mapper declarations into a map from mapper id's to
--   mapper definitions.
mapperDeclsToTxsDefs :: (MapsTo Text SortId mm, MapsTo Text (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo ProcId ProcDef mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc VarDeclE) VarId mm, In (Loc ChanRefE, Loc ChanDeclE) (Contents mm) ~  'False, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False, In (ProcId, ()) (Contents mm) ~  'False) => mm -> [MapperDecl] -> CompilerM (Map MapperId MapperDef)

-- | Compile a list of model declarations into a map from model id's to
--   model definitions.
modelDeclsToTxsDefs :: (MapsTo Text SortId mm, MapsTo Text (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo ProcId ProcDef mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc VarDeclE) VarId mm, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False, In (Loc ChanRefE, Loc ChanDeclE) (Contents mm) ~  'False, In (ProcId, ()) (Contents mm) ~  'False) => mm -> [ModelDecl] -> CompilerM (Map ModelId ModelDef)

-- | Compile a list of purpose declarations into a map from purpose id's to
--   purpose definitions.
purpDeclsToTxsDefs :: (MapsTo Text SortId mm, MapsTo Text (Loc ChanDeclE) mm, MapsTo (Loc ChanDeclE) ChanId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo ProcId ProcDef mm, MapsTo (Loc VarDeclE) SortId mm, MapsTo (Loc VarDeclE) VarId mm, In (ProcId, ()) (Contents mm) ~  'False, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False, In (Loc ChanRefE, Loc ChanDeclE) (Contents mm) ~  'False) => mm -> [PurpDecl] -> CompilerM (Map PurpId PurpDef)


-- | Compiler functions and instances on variable declarations.
module TorXakis.Compiler.Data.VarDecl
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId TorXakis.Parser.Data.VarDecl mm
instance TorXakis.Compiler.MapsTo.MapsTo (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) SortId.SortId mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE) VarId.VarId TorXakis.Parser.Data.VarDecl mm


-- | Compiler functions and instances on process declarations.
module TorXakis.Compiler.Data.ProcDecl

-- | Information about a process.
data ProcInfo
ProcInfo :: ProcId -> [(Loc ChanDeclE, ChanId)] -> [(Loc VarDeclE, VarId)] -> ProcInfo

-- | Get all the <tt>ProcId</tt>'s in a composite map.
allProcIds :: MapsTo (Loc ProcDeclE) ProcInfo mm => mm -> [ProcId]
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.In (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE, SortId.SortId) (TorXakis.Compiler.MapsTo.Contents mm) ~ 'GHC.Types.False) => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ProcDeclE) TorXakis.Compiler.Data.ProcDecl.ProcInfo TorXakis.Parser.Data.ProcDecl mm
instance (TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text SortId.SortId mm, TorXakis.Compiler.MapsTo.In (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.VarDeclE, SortId.SortId) (TorXakis.Compiler.MapsTo.Contents mm) ~ 'GHC.Types.False) => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ProcDeclE) TorXakis.Compiler.Data.ProcDecl.ProcInfo TorXakis.Parser.Data.StautDecl mm
instance TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.StautDecl ()
instance TorXakis.Compiler.MapsTo.MapsTo Data.Text.Internal.Text (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) mm => TorXakis.Compiler.Maps.DefinesAMap.DefinesAMap (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanRefE) (TorXakis.Parser.Data.Loc TorXakis.Parser.Data.ChanDeclE) TorXakis.Parser.Data.Transition mm


-- | Compilation functions related to <tt>TorXakis</tt> process
--   definitions.
module TorXakis.Compiler.Defs.ProcDef

-- | Compile a list of process definitions into a map from process id to
--   process definitions.
procDeclsToProcDefMap :: (MapsTo Text SortId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo (Loc ProcDeclE) ProcInfo mm, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False, In (Loc VarDeclE, VarId) (Contents mm) ~  'False, In (Loc ChanDeclE, ChanId) (Contents mm) ~  'False, In (Loc ChanRefE, Loc ChanDeclE) (Contents mm) ~  'False, In (ProcId, ()) (Contents mm) ~  'False, In (Loc VarDeclE, SortId) (Contents mm) ~  'False) => mm -> [ProcDecl] -> CompilerM (Map ProcId ProcDef)

-- | Compile a list of state automaton declarations into a process id to
--   process definition map.
stautDeclsToProcDefMap :: (MapsTo Text SortId mm, MapsTo (Loc VarRefE) (Either (Loc VarDeclE) [Loc FuncDeclE]) mm, MapsTo (Loc FuncDeclE) (Signature, Handler VarId) mm, MapsTo (Loc ProcDeclE) ProcInfo mm, In (Loc FuncDeclE, Signature) (Contents mm) ~  'False, In (Loc VarDeclE, VarId) (Contents mm) ~  'False, In (Loc ChanDeclE, ChanId) (Contents mm) ~  'False, In (Loc ChanRefE, Loc ChanDeclE) (Contents mm) ~  'False, In (ProcId, ()) (Contents mm) ~  'False, In (Loc VarDeclE, SortId) (Contents mm) ~  'False) => mm -> [StautDecl] -> CompilerM (Map ProcId ProcDef)


-- | Parser for type declarations (<tt>TorXakis</tt> ADT's)
module TorXakis.Parser.TypeDefs

-- | Parser for type declarations (<tt>TorXakis</tt> ADT's).
adtP :: TxsParser ADTDecl

-- | Parser for Sorts.
sortP :: TxsParser OfSort

-- | Parser of a list of identifiers declarations, with an associated sort.
--   The list of identifiers is delimited by the given start and end
--   symbols, and separated by a semi-colon.
--   
--   <pre>
--   identifiers :: Sort
--   </pre>
idOfSortsP :: String -> String -> (Text -> Loc t -> OfSort -> d) -> TxsParser [d]

-- | Parser for the declaration of a sort.
ofSortP :: TxsParser OfSort


-- | Parser for channel declarations
module TorXakis.Parser.ChanDecl
chanDeclsOfSortP :: TxsParser [ChanDecl]
chanDeclsP :: TxsParser [ChanDecl]


-- | Parser for value expression declarations.
module TorXakis.Parser.ValExprDecl

-- | Compound value expressions parser.
valExpP :: TxsParser ExpDecl

-- | Parser for a list of value declarations (where each value declaration
--   is a list of the form 'x0 = v0; ...; xn=vn'), which allow to introduce
--   values sequentially.
letSeqVarDeclsP :: TxsParser [ParLetVarDecl]

-- | Parser for let value declarations, separated by commas.
letVarDeclsP :: TxsParser ParLetVarDecl


-- | Parser for function definitions.
module TorXakis.Parser.FuncDefs

-- | Parser for function parameters.
fParamsP :: TxsParser [VarDecl]

-- | Parser for function declarations.
fDeclP :: TxsParser FuncDecl


-- | Parser for constant declarations.
module TorXakis.Parser.ConstDecl

-- | Parse a constant declaration. Constants are treated as nullary
--   functions.
constDeclsP :: TxsParser [FuncDecl]


-- | Parser for behavior expression declarations.
module TorXakis.Parser.BExpDecl

-- | Parser for behavior expressions declarations.
bexpDeclP :: TxsParser BExpDecl

-- | Parser for exit declarations.
procExitP :: TxsParser ExitSortDecl

-- | Parser for channel parameters.
chParamsP :: TxsParser [ChanDecl]

-- | Parser for offers.
offerP :: TxsParser OfferDecl

-- | Parser for Channel offers.
chanOfferP :: TxsParser ChanOfferDecl

-- | Parser for action offers.
actOfferP :: TxsParser ActOfferDecl

-- | Parser for offers.
offersP :: TxsParser [OfferDecl]


-- | Parser for purpose declarations.
module TorXakis.Parser.PurpDecl

-- | Parser for purpose declarations.
purpDeclP :: TxsParser PurpDecl


-- | Parser for process declarations.
module TorXakis.Parser.ProcDecl

-- | Parser for process declarations.
procDeclP :: TxsParser ProcDecl


-- | Parser for model declarations.
module TorXakis.Parser.ModelDecl

-- | Parser for model declarations.
modelDeclP :: TxsParser ModelDecl


-- | Parser for mapper declarations.
module TorXakis.Parser.MapperDecl

-- | Parser for mapper declarations.
mapperDeclP :: TxsParser MapperDecl


-- | Parser for connect declarations.
module TorXakis.Parser.CnectDecl

-- | Parser for connect declarations.
cnectDeclP :: TxsParser CnectDecl


-- | Parser for variable declarations.
module TorXakis.Parser.VarDecl

-- | Parser for variable declarations.
varDeclsP :: TxsParser [VarDecl]


-- | Parser for state automata declarations.
module TorXakis.Parser.StautDecl
stautDeclP :: TxsParser StautDecl


module TorXakis.Parser

-- | TorXakis definitions generated by the parser.
data ParsedDefs
adts :: Lens' ParsedDefs [ADTDecl]
funcs :: Lens' ParsedDefs [FuncDecl]
consts :: Lens' ParsedDefs [FuncDecl]
models :: Lens' ParsedDefs [ModelDecl]
chdecls :: Lens' ParsedDefs [ChanDecl]
procs :: Lens' ParsedDefs [ProcDecl]

-- | Root parser for the TorXakis language.
txsP :: TxsParser ParsedDefs

-- | Parse a TorXakis file from file.
parseFile :: FilePath -> IO (Either Error ParsedDefs)

-- | Parse a TorXakis file from a string.
parseString :: FilePath -> String -> Either Error ParsedDefs

-- | Parse a string using the initial value for the unique id's counter.
parse :: Int -> String -> String -> TxsParser a -> Either Error a


module TorXakis.Compiler

-- | Compile a string into a TorXakis model.
compileFile :: FilePath -> IO (Either Error (Id, TxsDefs, Sigs VarId))

-- | Run the compiler throwing an error if the compiler returns an
--   <a>Error</a>.
compileUnsafe :: CompilerM a -> a

-- | Sub-compiler for value definitions
compileValDefs :: Sigs VarId -> [VarId] -> Int -> String -> CompilerM (Id, Map VarId (ValExpr VarId))

-- | Sub-compiler for variable declarations.
compileVarDecls :: Sigs VarId -> Int -> String -> CompilerM (Id, [VarId])

-- | Sub-compiler for value expressions.
compileValExpr :: Sigs VarId -> [VarId] -> Int -> String -> CompilerM (Id, ValExpr VarId)

-- | Sub-compiler for behavior expressions.
compileBExpr :: Sigs VarId -> [ChanId] -> [VarId] -> Int -> String -> CompilerM (Id, BExpr)

-- | Sub-compiler for action prefix offers.
compileOffer :: Sigs VarId -> [ChanId] -> [VarId] -> Int -> String -> CompilerM (Id, Set Offer)

-- | Legacy compile function, used to comply with the old interface. It
--   should be deprecated in favor of <a>compileFile</a>.
compileLegacy :: String -> (Id, TxsDefs, Sigs VarId)
