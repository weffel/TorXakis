-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SMT Solver
--   
--   SMT Solver
@package solve
@version 0.2.2.0

module FreeVar

-- | Determine the free variables in Value Expression.
freeVars :: (Variable v) => ValExpr v -> [v]

-- | Is Value Expression closed?
isClosed :: (Variable v) => ValExpr v -> Bool

module SMTData
type SMT a = StateT SmtEnv IO a
data SmtEnv
SmtEnv :: Handle -> Handle -> Handle -> ProcessHandle -> Maybe Handle -> EnvNames -> EnvDefs -> SmtEnv
[inHandle] :: SmtEnv -> Handle
[outHandle] :: SmtEnv -> Handle
[errHandle] :: SmtEnv -> Handle
[smtProcessHandle] :: SmtEnv -> ProcessHandle
[logFileHandle] :: SmtEnv -> Maybe Handle
[envNames] :: SmtEnv -> EnvNames
[envDefs] :: SmtEnv -> EnvDefs
SmtEnvError :: SmtEnv
data EnvNames
EnvNames :: Map SortId Text -> Map CstrId Text -> Map FuncId Text -> EnvNames
[sortNames] :: EnvNames -> Map SortId Text
[cstrNames] :: EnvNames -> Map CstrId Text
[funcNames] :: EnvNames -> Map FuncId Text
data EnvDefs
EnvDefs :: Map SortId SortDef -> Map CstrId CstrDef -> Map FuncId (FuncDef VarId) -> EnvDefs
[sortDefs] :: EnvDefs -> Map SortId SortDef
[cstrDefs] :: EnvDefs -> Map CstrId CstrDef
[funcDefs] :: EnvDefs -> Map FuncId (FuncDef VarId)
instance GHC.Show.Show SMTData.EnvNames
instance GHC.Read.Read SMTData.EnvNames
instance GHC.Classes.Ord SMTData.EnvNames
instance GHC.Classes.Eq SMTData.EnvNames
instance GHC.Show.Show SMTData.EnvDefs
instance GHC.Read.Read SMTData.EnvDefs
instance GHC.Classes.Ord SMTData.EnvDefs
instance GHC.Classes.Eq SMTData.EnvDefs
instance GHC.Show.Show SMTData.SmtEnv

module SMTString

-- | Encode String to SMT.
--   
--   According to smt-lib-version 2.5 standard
--   (http:/<i>smtlib.cs.uiowa.edu</i>papers/smt-lib-reference-v2.5-r2015-06-28.pdf),
--   quote and escape characters are escaped.
--   
--   Furthermore, prevent CVC4 Parse Error "Extended/unprintable characters
--   are not part of SMT-LIB, and they must be encoded as escape sequences"
stringToSMT :: Text -> Text

-- | Decode SMT to String.
stringFromSMT :: Text -> Text


-- | Transcribe Regular Expression from XSD into SMT format.
--   
--   For more info on * XSD representation see
--   <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a> * SMT reprentation
--   see
--   <a>http://cvc4.cs.stanford.edu/wiki/Strings#Symbolic_Regular_Expression</a>
module RegexXSD2SMT

-- | Transcribe regular expression in XSD to SmtLib representation.
xsd2smt :: Text -> Text
instance GHC.Base.Functor RegexXSD2SMT.HappyIdentity
instance GHC.Base.Applicative RegexXSD2SMT.HappyIdentity
instance GHC.Base.Monad RegexXSD2SMT.HappyIdentity

module Solve.Params
type Params = Map String (String, String -> Bool)
initParams :: Params
data SolveStrategy
No :: SolveStrategy
Partition :: SolveStrategy
TrueBins :: SolveStrategy
IncrementChoice :: SolveStrategy
IncrementBins :: SolveStrategy
data StringMode
Regex :: StringMode
Length :: StringMode
data Next
Linear :: Next
Power :: Next
Exponent :: Next
instance GHC.Show.Show Solve.Params.Next
instance GHC.Read.Read Solve.Params.Next
instance GHC.Classes.Ord Solve.Params.Next
instance GHC.Classes.Eq Solve.Params.Next
instance GHC.Show.Show Solve.Params.StringMode
instance GHC.Read.Read Solve.Params.StringMode
instance GHC.Classes.Ord Solve.Params.StringMode
instance GHC.Classes.Eq Solve.Params.StringMode
instance GHC.Show.Show Solve.Params.SolveStrategy
instance GHC.Read.Read Solve.Params.SolveStrategy
instance GHC.Classes.Ord Solve.Params.SolveStrategy
instance GHC.Classes.Eq Solve.Params.SolveStrategy

module SolveDefs
type Solution v = Map v Constant
data SolvableProblem
Sat :: SolvableProblem
Unsat :: SolvableProblem
Unknown :: SolvableProblem
data SolveProblem v
Solved :: (Solution v) -> SolveProblem v
Unsolvable :: SolveProblem v
UnableToSolve :: SolveProblem v
instance GHC.Show.Show v => GHC.Show.Show (SolveDefs.SolveProblem v)
instance (GHC.Read.Read v, GHC.Classes.Ord v) => GHC.Read.Read (SolveDefs.SolveProblem v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (SolveDefs.SolveProblem v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (SolveDefs.SolveProblem v)
instance GHC.Show.Show SolveDefs.SolvableProblem
instance GHC.Read.Read SolveDefs.SolvableProblem
instance GHC.Classes.Ord SolveDefs.SolvableProblem
instance GHC.Classes.Eq SolveDefs.SolvableProblem

module SMT
createSMTEnv :: CreateProcess -> Bool -> IO SmtEnv
openSolver :: SMT String
close :: SMT ()
addDefinitions :: EnvDefs -> SMT ()
addDeclarations :: (Variable v) => [v] -> SMT ()
addAssertions :: (Variable v) => [ValExpr v] -> SMT ()
getSolvable :: SMT SolvableProblem
getSolution :: (Variable v) => [v] -> SMT (Solution v)
push :: SMT ()
pop :: SMT ()

-- | execute the SMT command given as a string
put :: String -> SMT ()
putT :: Text -> SMT ()

-- | Transform value expression to an SMT string.
valExprToString :: Variable v => ValExpr v -> SMT Text

module RandTrueBins
randValExprsSolveTrueBins :: (Variable v) => ParamTrueBins -> [v] -> [ValExpr v] -> SMT (SolveProblem v)
data ParamTrueBins
ParamTrueBins :: Int -> Next -> Int -> StringMode -> Int -> ParamTrueBins
[maxDepth] :: ParamTrueBins -> Int
[next] :: ParamTrueBins -> Next
[nrOfBins] :: ParamTrueBins -> Int
[stringMode] :: ParamTrueBins -> StringMode
[stringLength] :: ParamTrueBins -> Int
instance GHC.Show.Show RandTrueBins.ParamTrueBins
instance GHC.Read.Read RandTrueBins.ParamTrueBins
instance GHC.Classes.Ord RandTrueBins.ParamTrueBins
instance GHC.Classes.Eq RandTrueBins.ParamTrueBins

module RandPartition
randValExprsSolvePartition :: (Variable v) => ParamPartition -> [v] -> [ValExpr v] -> SMT (SolveProblem v)
data ParamPartition
ParamPartition :: Int -> Int -> Int -> ParamPartition
[maxDepth] :: ParamPartition -> Int
[intHalf] :: ParamPartition -> Int
[intNum] :: ParamPartition -> Int
instance GHC.Show.Show RandPartition.ParamPartition
instance GHC.Read.Read RandPartition.ParamPartition
instance GHC.Classes.Ord RandPartition.ParamPartition
instance GHC.Classes.Eq RandPartition.ParamPartition

module RandIncrementChoice
randValExprsSolveIncrementChoice :: (Variable v) => ParamIncrementChoice -> [v] -> [ValExpr v] -> SMT (SolveProblem v)
data ParamIncrementChoice
ParamIncrementChoice :: Int -> Int -> Int -> Int -> ParamIncrementChoice
[maxDepth] :: ParamIncrementChoice -> Int
[intRange] :: ParamIncrementChoice -> Int
[intPower] :: ParamIncrementChoice -> Int
[maxGeneratedStringLength] :: ParamIncrementChoice -> Int
instance GHC.Show.Show RandIncrementChoice.ParamIncrementChoice
instance GHC.Read.Read RandIncrementChoice.ParamIncrementChoice
instance GHC.Classes.Ord RandIncrementChoice.ParamIncrementChoice
instance GHC.Classes.Eq RandIncrementChoice.ParamIncrementChoice

module RandIncrementBins
randValExprsSolveIncrementBins :: (Variable v) => ParamIncrementBins -> [v] -> [ValExpr v] -> SMT (SolveProblem v)
data ParamIncrementBins
ParamIncrementBins :: Int -> Next -> Int -> ParamIncrementBins
[maxDepth] :: ParamIncrementBins -> Int
[next] :: ParamIncrementBins -> Next
[nrOfBins] :: ParamIncrementBins -> Int
instance GHC.Show.Show RandIncrementBins.ParamIncrementBins
instance GHC.Read.Read RandIncrementBins.ParamIncrementBins
instance GHC.Classes.Ord RandIncrementBins.ParamIncrementBins
instance GHC.Classes.Eq RandIncrementBins.ParamIncrementBins

module Solve
satSolve :: (Variable v) => [v] -> Assertions v -> SMT SolvableProblem
solve :: (Variable v) => [v] -> Assertions v -> SMT (SolveProblem v)
uniSolve :: (Variable v) => [v] -> Assertions v -> SMT (SolveProblem v)
randSolve :: (Variable v) => SolveRandParam -> [v] -> Assertions v -> SMT (SolveProblem v)
data Assertions v
empty :: Assertions v
add :: (Variable v) => ValExpr v -> Assertions v -> Assertions v
data SolveRandParam
RandNo :: SolveRandParam
RandPartition :: ParamPartition -> SolveRandParam
RandTrueBins :: ParamTrueBins -> SolveRandParam
RandIncrementChoice :: ParamIncrementChoice -> SolveRandParam
RandIncrementBins :: ParamIncrementBins -> SolveRandParam
toRandParam :: Params -> SolveRandParam
instance GHC.Classes.Ord v => GHC.Classes.Ord (Solve.Assertions v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Solve.Assertions v)
instance GHC.Show.Show v => GHC.Show.Show (Solve.PrivateAssertions v)
instance (GHC.Classes.Ord v, GHC.Read.Read v) => GHC.Read.Read (Solve.PrivateAssertions v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Solve.PrivateAssertions v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Solve.PrivateAssertions v)
instance Variable.Variable v => GHC.Show.Show (Solve.Assertions v)
